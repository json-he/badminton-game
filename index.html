<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- å¼ºåˆ¶ç¼“å­˜æ§åˆ¶å’Œç‰ˆæœ¬ç®¡ç† - GitHub Pagesä¸“ç”¨ -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="version" content="1.3.1">
    <meta name="build-time" content="2025-01-17-UPDATE">
    <meta name="last-modified" content="2025-01-17">
    
    <!-- GitHub Pageså¼ºåˆ¶åˆ·æ–° -->
    <script>
        // ç‰ˆæœ¬æ£€æŸ¥å’Œå¼ºåˆ¶åˆ·æ–°æœºåˆ¶
        (function() {
            const currentVersion = '1.3.1';
            const buildTime = '2025-01-17-UPDATE';
            const storageKey = 'badminton_version';
            const lastVersion = localStorage.getItem(storageKey);
            
            // å¦‚æœç‰ˆæœ¬ä¸åŒ¹é…ï¼Œæ¸…ç†æ‰€æœ‰ç¼“å­˜
            if (lastVersion !== currentVersion) {
                console.log(`ğŸ”„ ç‰ˆæœ¬æ›´æ–°æ£€æµ‹: ${lastVersion} â†’ ${currentVersion}`);
                
                // æ¸…ç†localStorage
                const keysToKeep = ['leancloud_app_id', 'leancloud_app_key']; // ä¿ç•™äº‘ç«¯é…ç½®
                Object.keys(localStorage).forEach(key => {
                    if (!keysToKeep.includes(key)) {
                        localStorage.removeItem(key);
                    }
                });
                
                // æ¸…ç†sessionStorage
                sessionStorage.clear();
                
                // æ¸…ç†æ‰€æœ‰ç¼“å­˜ï¼ˆå¦‚æœæ”¯æŒï¼‰
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => caches.delete(name));
                    });
                }
                
                // è®¾ç½®æ–°ç‰ˆæœ¬
                localStorage.setItem(storageKey, currentVersion);
                localStorage.setItem('badminton_build_time', buildTime);
                
                console.log('âœ… ç¼“å­˜å·²æ¸…ç†ï¼ŒåŠ è½½æœ€æ–°ç‰ˆæœ¬');
            }
        })();
    </script>
    
    <title>ç¾½æ¯›çƒæ¯”èµ›ç³»ç»Ÿ</title>
    
    <!-- LeanCloud SDK - å›½å†…æœ€ä½³å®æ—¶æ•°æ®åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/leancloud-storage@4.15.2/dist/av-min.js"></script>
    <!-- LeanCloud å®æ—¶é€šä¿¡SDK -->
    <script src="https://cdn.jsdelivr.net/npm/leancloud-realtime@5.0.0/dist/realtime.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        input, button {
            -webkit-user-select: auto;
            -moz-user-select: auto;
            -ms-user-select: auto;
            user-select: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            margin: 0;
            overflow-x: hidden;
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            min-height: calc(100vh - 20px);
            overscroll-behavior: none;
            -webkit-overscroll-behavior: none;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            line-height: 1.2;
        }

        .header p {
            color: #7f8c8d;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* é¡µé¢åˆ‡æ¢ */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* ç©å®¶åå• */
        .players-list {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .players-list h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .players-names {
            color: #495057;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* æ¯”èµ›é¢„è§ˆ */
        .rounds-preview {
            margin: 20px 0;
        }

        .round-preview {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .round-preview h3 {
            color: #2c3e50;
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(45deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .preview-matches {
            display: grid;
            gap: 8px;
        }

        .preview-match {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            font-size: 0.85rem;
            color: #495057;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .preview-match:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .preview-match:active {
            transform: scale(0.98);
        }

        .preview-match.completed {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border-color: #28a745;
        }

        .preview-match.completed::after {
            content: 'âœ…';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 1rem;
        }

        .preview-match.incomplete {
            background: #fff3cd;
            border-color: #ffc107;
            animation: pulse-incomplete 2s infinite;
        }

        @keyframes pulse-incomplete {
            0% { box-shadow: 0 4px 15px rgba(255, 193, 7, 0.2); }
            50% { box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4); }
            100% { box-shadow: 0 4px 15px rgba(255, 193, 7, 0.2); }
        }

        .match-score {
            font-weight: bold;
            font-size: 1rem;
            color: #667eea;
            background: white;
            padding: 6px 12px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            min-width: 60px;
            align-self: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .match-score.has-score {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border-color: #28a745;
        }

        /* å¯ç‚¹å‡»ç©å®¶åå­—æ ·å¼ */
        .clickable-player-name {
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .clickable-player-name:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #667eea;
            color: #667eea;
        }

        .clickable-player-name.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .match-score:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        /* æ§åˆ¶æŒ‰é’® */
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 20px 0;
        }

        .control-btn {
            padding: 14px 24px;
            border: none;
            border-radius: 25px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 48px;
            width: 100%;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .control-btn:hover, .control-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            transform: scale(0.98);
        }

        /* é«˜çº§æ¯”åˆ†é€‰æ‹©å™¨ */
        .advanced-score-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .advanced-score-modal.active {
            display: flex;
        }

        .advanced-modal-content {
            background: white;
            border-radius: 20px;
            padding: 25px;
            width: 350px;
            max-width: 90vw;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .teams-score-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 25px 0;
            gap: 20px;
        }

        .team-score-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .team-name-display {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            text-align: center;
            line-height: 1.3;
        }

        .score-wheel-container {
            position: relative;
            height: 120px;
            width: 80px;
            overflow: hidden;
            border-radius: 15px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #dee2e6;
            cursor: pointer;
            user-select: none;
        }


        .score-wheel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .score-item {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .score-item.center {
            color: #667eea;
            font-size: 1.6rem;
            background: linear-gradient(45deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .score-item.adjacent {
            font-size: 1rem;
            color: #adb5bd;
        }

        .score-item.distant {
            font-size: 0.8rem;
            color: #ced4da;
        }

        .vs-separator {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .score-controls {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .score-control-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .btn-save-scores {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .btn-save-scores:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .btn-save-scores:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-cancel-scores {
            background: #6c757d;
            color: white;
        }

        .btn-cancel-scores:hover {
            background: #5a6268;
        }

        .score-status {
            margin: 15px 0;
            font-size: 0.85rem;
            color: #6c757d;
        }

        .score-status.complete {
            color: #28a745;
            font-weight: 600;
        }

        /* è‡ªå®šä¹‰å¼¹æ¡† */
        .custom-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .custom-dialog.active {
            display: flex;
        }

        .dialog-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            width: 340px;
            max-width: 90vw;
            text-align: center;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.3);
            animation: dialogSlideIn 0.3s ease-out;
        }

        @keyframes dialogSlideIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .dialog-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
        }

        .dialog-icon.info {
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .dialog-icon.warning {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
        }

        .dialog-icon.success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .dialog-icon.error {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .dialog-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .dialog-message {
            color: #6c757d;
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 25px;
            white-space: pre-line;
        }

        .dialog-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .dialog-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .dialog-btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .dialog-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .dialog-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .dialog-btn-secondary:hover {
            background: #5a6268;
        }

        /* LoadingçŠ¶æ€ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(102, 126, 234, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            color: white;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .loading-subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
            text-align: center;
            line-height: 1.4;
        }

        /* æ’åè¡¨æ ¼ */
        .results-table {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .results-table h3 {
            text-align: center;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .results-grid {
            display: grid;
            gap: 8px;
        }

        .result-row {
            display: grid;
            grid-template-columns: 50px 1fr 50px 50px 70px;
            align-items: center;
            padding: 12px;
            background: white;
            border-radius: 10px;
            font-size: 0.9rem;
            margin-bottom: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border-left: 4px solid transparent;
        }

        .result-row.header {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 12px;
            border-left: none;
        }

        .result-row.winner {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            font-weight: bold;
            border-left-color: #ffd700;
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.3);
        }

        .result-row:not(.header):not(.winner) {
            border-left-color: #e9ecef;
        }

        .result-row:not(.header):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        .rank-cell {
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
        }

        .name-cell {
            font-weight: 600;
            color: #2c3e50;
        }

        .score-cell {
            text-align: center;
            font-weight: 500;
        }

        .net-score-positive {
            color: #28a745;
            font-weight: bold;
        }

        .net-score-negative {
            color: #dc3545;
            font-weight: bold;
        }

        .net-score-zero {
            color: #6c757d;
        }


        .sync-notification {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 10px 16px;
            border-radius: 25px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }

        /* ç©å®¶é…ç½®æ ·å¼ */

        .player-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 15px;
            margin-bottom: 12px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .player-item.active {
            border-color: #28a745;
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            transform: scale(1.02);
        }

        .player-item.inactive {
            border-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            opacity: 0.8;
        }

        .player-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            font-size: 1.1rem;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .player-info {
            flex: 1;
        }

        .player-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 2px;
        }

        .player-status {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .player-name-input {
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 0.95rem;
            width: 130px;
            font-weight: 600;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .player-name-input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .player-toggle {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 70px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .player-toggle.active {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .player-toggle.inactive {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .player-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        /* ç©å®¶ç­›é€‰åŠŸèƒ½æ ·å¼ */
        .player-item.filterable {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .player-item.filterable:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .player-item.selected-filter {
            background: linear-gradient(135deg, #007bff, #0056b3);
            border-color: #0056b3;
            color: white;
        }

        .player-item.selected-filter .player-name {
            color: white;
        }

        .player-item.selected-filter .player-status {
            color: rgba(255,255,255,0.8);
        }

        .filter-status {
            margin: 15px 0;
            padding: 15px 20px;
            background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
            border-radius: 12px;
            font-size: 0.95rem;
            color: #2e7d32;
            border-left: 5px solid #4caf50;
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.2);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .filter-clear-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }

        .filter-clear-btn:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        .filter-clear-btn:active {
            transform: scale(0.95);
        }

        .preview-match.filtered-out {
            opacity: 0.2;
            filter: grayscale(100%);
            pointer-events: none;
            transform: scale(0.98);
            transition: all 0.3s ease;
        }
        
        .preview-match:not(.filtered-out) {
            transition: all 0.3s ease;
        }

        /* ç©å®¶ç­›é€‰å™¨æ ·å¼ */
        .player-filter-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #e9ecef;
        }

        .player-filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .player-filter-btn {
            padding: 8px 16px;
            border: 2px solid #dee2e6;
            border-radius: 20px;
            background: white;
            color: #495057;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            user-select: none;
        }

        .player-filter-btn:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .player-filter-btn.selected {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .player-filter-btn.selected:hover {
            transform: translateY(-1px) scale(1.02);
        }

        .filter-match-count {
            font-weight: bold;
            color: #007bff;
        }

        /* æ¯”èµ›å®‰æ’å¯è§†åŒ–æ ·å¼ */
        .schedule-round {
            margin-bottom: 25px;
        }

        .schedule-round-title {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 15px;
        }

        .schedule-matches {
            display: grid;
            gap: 10px;
        }

        .schedule-match {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .match-teams {
            flex: 1;
            text-align: center;
            font-weight: 600;
            color: #2c3e50;
        }

        .match-rest {
            background: #f8f9fa;
            color: #6c757d;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
        }

        .player-schedule-grid {
            display: grid;
            grid-template-columns: 100px repeat(15, 30px);
            gap: 2px;
            margin: 15px 0;
            font-size: 0.8rem;
        }

        .schedule-header {
            display: contents;
        }

        .schedule-player-name {
            font-weight: 600;
            color: #2c3e50;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            text-align: center;
        }

        .schedule-cell {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .schedule-cell.playing {
            background: #28a745;
            color: white;
        }

        .schedule-cell.resting {
            background: #dc3545;
            color: white;
        }

        .schedule-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¸ ç¾½æ¯›çƒæ¯”èµ›ç³»ç»Ÿ</h1>
            <p>6äººè½®è½¬åˆ¶ - 15åœºæ¯”èµ›ï¼Œæ¯äºº10åœº</p>
            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.7); margin-top: 5px; display: flex; justify-content: space-between; align-items: center;">
                <span>v1.3.1 - 2025.01.17</span>
                <button onclick="forceRefresh()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; cursor: pointer; transition: all 0.2s;" 
                        onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.borderColor='rgba(255,255,255,0.5)'" 
                        onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.borderColor='rgba(255,255,255,0.3)'">
                    æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬
                </button>
            </div>
        </div>

        <!-- ä¸»é¡µé¢ -->
        <div id="mainPage" class="page active">
            <div class="players-list">
                <h4>ğŸ“‹ å‚èµ›äººå‘˜åå•</h4>
                <div class="players-names" id="playersNames">
                    <!-- ç©å®¶åå•å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                </div>
                
                <!-- ç©å®¶ç­›é€‰å™¨ -->
                <div class="player-filter-section" id="playerFilterSection" style="margin-top: 15px;">
                    <h5 style="margin-bottom: 10px; color: #666;">ğŸ” ç­›é€‰ç©å®¶</h5>
                    <div class="player-filter-buttons" id="playerFilterButtons">
                        <!-- ç­›é€‰æŒ‰é’®å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                    </div>
                </div>
        </div>

            <div class="matches-preview" id="matchesPreview">
                <div id="initialLoading" style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ¸</div>
                    <div>æ­£åœ¨åŠ è½½æ¯”èµ›ç³»ç»Ÿ...</div>
                    <div style="font-size: 0.8rem; margin-top: 5px; opacity: 0.7;">è¯·ç¨ç­‰ç‰‡åˆ»</div>
                </div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="game-controls">
                <button class="control-btn btn-success" onclick="showFinalRanking()" id="showRankingBtn">
                    ğŸ“Š æŸ¥çœ‹æœ€ç»ˆæ’å
                </button>
                <button class="control-btn btn-warning" onclick="showPlayerConfigModal()">
                    ğŸ‘¥ é…ç½®å‚èµ›äººå‘˜
                </button>
                <button class="control-btn btn-danger" onclick="clearAllFilters()" id="clearFilterBtn" style="display: none;">
                    ğŸ” æ¸…é™¤ç­›é€‰
                </button>
                <button class="control-btn btn-primary" onclick="regenerateMatches()">
                    ğŸ² é‡æ–°å¼€å§‹æ¯”èµ›
                </button>
            </div>
            
            <!-- æœ€ç»ˆæ’å -->
            <div class="final-ranking" id="finalRanking" style="display: none;">
                <div class="results-table">
                    <h3>ğŸ† æœ€ç»ˆæ’å</h3>
                    <div class="results-grid" id="resultsGrid">
                        <!-- ç»“æœå°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                    </div>
                </div>
                <button class="control-btn btn-warning" onclick="hideFinalRanking()" style="margin-top: 15px;">
                    âŒ å…³é—­æ’å
                </button>
            </div>
        </div>
        </div>

    <!-- LoadingçŠ¶æ€ -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">æ­£åœ¨è¿æ¥äº‘ç«¯...</div>
        <div class="loading-subtitle">æ­£åœ¨ä»LeanCloudäº‘ç«¯åŠ è½½æœ€æ–°æ¯”åˆ†æ•°æ®<br>è¯·ç¨ç­‰ç‰‡åˆ»</div>
    </div>

    <!-- é«˜çº§æ¯”åˆ†é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
    <div id="advancedScoreModal" class="advanced-score-modal">
        <div class="advanced-modal-content">
            <h3 id="advancedScoreTitle">è®°å½•æ¯”åˆ†</h3>
            <div class="score-status" id="scoreStatus">è¯·ä¸ºåŒæ–¹é˜Ÿä¼è®¾ç½®æ¯”åˆ†</div>
            
            <div class="teams-score-section">
                <!-- é˜Ÿä¼1 -->
                <div class="team-score-container">
                    <div class="team-name-display" id="team1Name">é˜Ÿä¼1</div>
                    <div class="score-wheel-container" 
                         ontouchstart="handleTouchStart(event, 0)" 
                         ontouchmove="handleTouchMove(event, 0)" 
                         ontouchend="handleTouchEnd(event, 0)"
                         onmousedown="handleMouseDown(event, 0)"
                         onmousemove="handleMouseMove(event, 0)"
                         onmouseup="handleMouseUp(event, 0)"
                         onwheel="handleWheelScroll(event, 0)">
                        <div class="score-wheel" id="scoreWheel1">
                            <!-- æ¯”åˆ†è½®æ’­é¡¹å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <div class="vs-separator">VS</div>

                <!-- é˜Ÿä¼2 -->
                <div class="team-score-container">
                    <div class="team-name-display" id="team2Name">é˜Ÿä¼2</div>
                    <div class="score-wheel-container" 
                         ontouchstart="handleTouchStart(event, 1)" 
                         ontouchmove="handleTouchMove(event, 1)" 
                         ontouchend="handleTouchEnd(event, 1)"
                         onmousedown="handleMouseDown(event, 1)"
                         onmousemove="handleMouseMove(event, 1)"
                         onmouseup="handleMouseUp(event, 1)"
                         onwheel="handleWheelScroll(event, 1)">
                        <div class="score-wheel" id="scoreWheel2">
                            <!-- æ¯”åˆ†è½®æ’­é¡¹å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="score-controls">
                <button class="score-control-btn btn-save-scores" onclick="saveMatchScores()" id="saveScoresBtn" disabled>
                    ä¿å­˜æ¯”åˆ†
                </button>
                <button class="score-control-btn btn-cancel-scores" onclick="closeAdvancedScoreModal()">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    </div>

    <!-- ç©å®¶é…ç½®å¼¹æ¡† -->
    <div id="playerConfigModal" class="advanced-score-modal">
        <div class="advanced-modal-content" style="width: 400px; max-width: 95vw; max-height: 90vh; overflow-y: auto;">
            <div style="text-align: center; margin-bottom: 25px; position: sticky; top: 0; background: white; z-index: 10; padding: 15px 0; border-bottom: 2px solid #f0f0f0;">
                <h3 style="color: #2c3e50; margin: 0; font-size: 1.3rem; font-weight: 700;">ğŸ‘¥ é…ç½®å‚èµ›äººå‘˜</h3>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="text-align: center; color: #666; font-size: 0.9rem;">
                    <span id="currentModeText">æ ¹æ®å‚èµ›äººæ•°è‡ªåŠ¨ç¡®å®šæ¯”èµ›æ¨¡å¼</span>
                </div>
            </div>

            <div class="player-list-config" id="playerListConfig">
                <!-- ç©å®¶åˆ—è¡¨å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
            </div>

            <!-- ç­›é€‰çŠ¶æ€æ˜¾ç¤º -->
            <div id="filterStatus" class="filter-status" style="display: none;">
                <!-- ç­›é€‰çŠ¶æ€å°†é€šè¿‡JavaScriptæ›´æ–° -->
            </div>

            <div class="fairness-info" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 20px 0; font-size: 0.85rem; color: #495057;">
                <div style="font-weight: 600; margin-bottom: 8px;">ğŸ“Š å…¬å¹³æ€§è¯´æ˜ï¼š</div>
                <div id="fairnessDescription">
                    <!-- å…¬å¹³æ€§æè¿°å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                </div>
            </div>

            <div style="position: sticky; bottom: 0; background: white; padding: 20px 0 10px 0; border-top: 2px solid #f0f0f0; margin-top: 25px; display: flex; gap: 12px;">
                <button onclick="savePlayerConfig()" style="flex: 1; padding: 14px 20px; background: linear-gradient(45deg, #28a745, #20c997); color: white; border: none; border-radius: 25px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);">
                    âœ… ä¿å­˜é…ç½®
                </button>
                <button onclick="closePlayerConfigModal()" style="flex: 1; padding: 14px 20px; background: linear-gradient(45deg, #6c757d, #5a6268); color: white; border: none; border-radius: 25px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);">
                    âŒ å–æ¶ˆå…³é—­
                </button>
            </div>
        </div>
    </div>

    <!-- æ¯”èµ›å®‰æ’å¯è§†åŒ–å¼¹æ¡† -->
    <div id="scheduleModal" class="advanced-score-modal">
        <div class="advanced-modal-content" style="width: 500px; max-width: 95vw; max-height: 90vh; overflow-y: auto;">
            <h3 style="text-align: center; margin-bottom: 20px; color: #2c3e50;">ğŸ“… æ¯”èµ›å®‰æ’æ€»è§ˆ</h3>
            
            <div class="schedule-overview" id="scheduleOverview">
                <!-- æ¯”èµ›å®‰æ’å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
            </div>

            <div class="schedule-summary" id="scheduleSummary" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin: 20px 0; font-size: 0.85rem; color: #495057;">
                <!-- ç»Ÿè®¡æ‘˜è¦å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
            </div>

            <div class="score-controls">
                <button class="score-control-btn btn-cancel-scores" onclick="closeScheduleModal()">
                    å…³é—­
                </button>
            </div>
        </div>
    </div>

    <!-- è‡ªå®šä¹‰å¼¹æ¡† -->
    <div id="customDialog" class="custom-dialog">
        <div class="dialog-content">
            <div class="dialog-icon" id="dialogIcon">
                <span id="dialogIconText">â„¹ï¸</span>
            </div>
            <div class="dialog-title" id="dialogTitle">æç¤º</div>
            <div class="dialog-message" id="dialogMessage">æ¶ˆæ¯å†…å®¹</div>
            <div class="dialog-buttons" id="dialogButtons">
                <!-- æŒ‰é’®å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        let selectedRound = 0;
        let selectedMatch = 0;
        let team1Score = 0;
        let team2Score = 0;
        let team1ScoreSet = false;
        let team2ScoreSet = false;

        // è§¦æ‘¸å’Œæ‹–æ‹½çŠ¶æ€
        let touchStartY = 0;
        let isDragging = false;

        // äº‘ç«¯åŒæ­¥çŠ¶æ€
        let isConnected = false;
        let saveToSync = null;

        // ç”Ÿæˆç”¨æˆ·ID
        window.currentUserId = 'user-' + Math.random().toString(36).substr(2, 6);
        window.lastActionType = 'init';

        // ç©å®¶é…ç½® - æ”¯æŒ5-6äººåŠ¨æ€è°ƒæ•´
        let playerConfig = [
            { name: 'ä¹±ä¸ƒå…«è•‰', avatar: 'ä¹±', id: 1, active: true },
            { name: 'å¤©çŸ¥åœ°ä»˜', avatar: 'å¤©', id: 2, active: true },
            { name: 'è…¿ç¥', avatar: 'è…¿', id: 3, active: true },
            { name: 'ä½•å±±æ°´', avatar: 'ä½•', id: 4, active: true },
            { name: 'æ¡çƒå¤§ç‹', avatar: 'æ¡', id: 5, active: true },
            { name: 'ä¸€å‰‘éœœ', avatar: 'å‰‘', id: 6, active: true }
        ];

        // å½“å‰å‚èµ›äººæ•°
        let currentPlayerCount = 6;

        // æ¯”èµ›å®‰æ’
        let matchSchedule = [];
        
        // ç­›é€‰åŠŸèƒ½ç›¸å…³å˜é‡
        let selectedPlayers = new Set(); // ç­›é€‰é€‰ä¸­çš„ç©å®¶

        // è·å–å½“å‰æ´»è·ƒç©å®¶
        function getActivePlayers() {
            return playerConfig.filter(p => p.active);
        }

        // ç”Ÿæˆ15åœºæ¯”èµ›çš„å®Œå…¨å…¬å¹³å®‰æ’
        function generateRandomMatches() {
            console.log('ğŸš€ å¼€å§‹ç”Ÿæˆæ¯”èµ›å®‰æ’...');
            
            const activePlayers = getActivePlayers();
            const players = activePlayers.map(p => p.name);
            const playerCount = players.length;
            
            console.log(`ğŸ‘¥ å‚èµ›äººå‘˜: ${players.join(', ')}`);
            
            if (playerCount === 6) {
                console.log('ğŸ¯ ä½¿ç”¨6äºº15åœºæ•°å­¦å®Œç¾ç®—æ³•...');
                matchSchedule = generatePerfect15Matches(players);
            } else if (playerCount === 5) {
                console.log('ğŸ¯ ä½¿ç”¨5äºº15åœºæ•°å­¦å®Œç¾ç®—æ³•...');  
                matchSchedule = generatePerfect5Matches(players);
            } else {
                showAlert(`æš‚ä¸æ”¯æŒ${playerCount}äººæ¯”èµ›æ¨¡å¼\n\nè¯·é€‰æ‹©5äººæˆ–6äººå‚èµ›`, 'âš ï¸ ä¸æ”¯æŒçš„äººæ•°', 'warning');
                return;
            }
            
            // éªŒè¯ç»“æœ
            if (!matchSchedule || matchSchedule.length === 0) {
                showAlert('ç”Ÿæˆæ¯”èµ›å¤±è´¥ï¼Œè¯·é‡è¯•', 'âŒ ç”Ÿæˆå¤±è´¥', 'error');
                return;
            }
            
            console.log(`âœ… æˆåŠŸç”Ÿæˆ${matchSchedule.length}åœºæ¯”èµ›ï¼`);
        }

        // å…¨æ–°ç®—æ³•ï¼šæ™ºèƒ½å¹³è¡¡åˆ†é…ç³»ç»Ÿ
        function generatePerfect15Matches(players) {
            console.log('ğŸ”¥ 6äºº15åœºæ¯”èµ› - æ•°å­¦å®Œç¾ç®—æ³•');
            console.log('â±ï¸ æ—¶é—´ï¼š15åœº Ã— 10åˆ†é’Ÿ = 2å°æ—¶30åˆ†é’Ÿ');
            console.log('âœ¨ ä¿è¯ï¼šæ¯äººæ°å¥½10åœºï¼Œæ¯å¯¹æ­æ¡£æ°å¥½2æ¬¡');
            console.log('ğŸ’ª æ™ºèƒ½æ§åˆ¶ï¼šé¿å…è¿‡åº¦è¿ç»­ï¼Œä¼‘æ¯åˆç†åˆ†å¸ƒ');
            
            // æ ‡å‡†6äºº15åœºå®‰æ’ - æ•°å­¦å®Œç¾ï¼Œæ­é…å…¬å¹³ï¼Œä¼‘æ¯åˆç†
            const matches = [
                {team1: [players[0], players[1]], team2: [players[2], players[3]], score1: 0, score2: 0}, // ç¬¬1åœºï¼š45ä¼‘æ¯
                {team1: [players[4], players[5]], team2: [players[0], players[2]], score1: 0, score2: 0}, // ç¬¬2åœºï¼š13ä¼‘æ¯
                {team1: [players[1], players[3]], team2: [players[4], players[0]], score1: 0, score2: 0}, // ç¬¬3åœºï¼š25ä¼‘æ¯
                {team1: [players[2], players[5]], team2: [players[1], players[4]], score1: 0, score2: 0}, // ç¬¬4åœºï¼š03ä¼‘æ¯
                {team1: [players[0], players[3]], team2: [players[2], players[4]], score1: 0, score2: 0}, // ç¬¬5åœºï¼š15ä¼‘æ¯
                
                {team1: [players[1], players[5]], team2: [players[3], players[4]], score1: 0, score2: 0}, // ç¬¬6åœºï¼š02ä¼‘æ¯
                {team1: [players[0], players[2]], team2: [players[1], players[4]], score1: 0, score2: 0}, // ç¬¬7åœºï¼š35ä¼‘æ¯
                {team1: [players[3], players[5]], team2: [players[0], players[4]], score1: 0, score2: 0}, // ç¬¬8åœºï¼š12ä¼‘æ¯
                {team1: [players[1], players[2]], team2: [players[4], players[5]], score1: 0, score2: 0}, // ç¬¬9åœºï¼š03ä¼‘æ¯
                {team1: [players[0], players[1]], team2: [players[3], players[5]], score1: 0, score2: 0}, // ç¬¬10åœºï¼š24ä¼‘æ¯
                
                {team1: [players[2], players[4]], team2: [players[0], players[1]], score1: 0, score2: 0}, // ç¬¬11åœºï¼š35ä¼‘æ¯
                {team1: [players[1], players[3]], team2: [players[2], players[5]], score1: 0, score2: 0}, // ç¬¬12åœºï¼š04ä¼‘æ¯
                {team1: [players[0], players[3]], team2: [players[1], players[5]], score1: 0, score2: 0}, // ç¬¬13åœºï¼š24ä¼‘æ¯
                {team1: [players[2], players[3]], team2: [players[0], players[5]], score1: 0, score2: 0}, // ç¬¬14åœºï¼š14ä¼‘æ¯
                {team1: [players[1], players[2]], team2: [players[0], players[4]], score1: 0, score2: 0}  // ç¬¬15åœºï¼š35ä¼‘æ¯
            ];
            
            // å·²åœ¨ä¸Šé¢æ•°ç»„ä¸­ä¿®å¤ï¼Œæ— éœ€é¢å¤–ä¿®å¤
            
            // æ·»åŠ matchIndex
            matches.forEach((match, index) => {
                match.matchIndex = index;
            });
            
            // éªŒè¯å®Œç¾æ€§
            validatePerfection(matches, players);
            
            return matches;
        }

        // æ•°å­¦å®Œç¾çš„5äºº15åœºæ¯”èµ›ç”Ÿæˆ - ä¼˜åŒ–ç‰ˆæœ¬ï¼ˆé¿å…è¿ç»­ä¼‘æ¯/æ¯”èµ›ï¼‰
        function generatePerfect5Matches(players) {
            console.log('ğŸ”¥ 5äºº15åœºæ¯”èµ› - é¢„è®¾å®Œç¾å®‰æ’');
            console.log('â±ï¸ æ—¶é—´ï¼š15åœº Ã— 10åˆ†é’Ÿ = 2å°æ—¶30åˆ†é’Ÿ');
            console.log('âœ¨ ä¿è¯ï¼šæ¯äººæ°å¥½12åœºï¼Œæ­é…ç›¸å¯¹å‡è¡¡');
            console.log('ğŸ“‹ ç›´æ¥è¿”å›é¢„è®¾çš„15åœºæ¯”èµ›å®‰æ’');
            
            // é‡æ–°è®¾è®¡çš„5äºº15åœºå®‰æ’ï¼šç¡®ä¿æ­é…å…¬å¹³ï¼ˆæ¯å¯¹2-3æ¬¡ï¼‰
            const matches = [
                // ç¬¬1åœºï¼šç©å®¶4ä¼‘æ¯
                {team1: [players[0], players[1]], team2: [players[2], players[3]], score1: 0, score2: 0},
                // ç¬¬2åœºï¼šç©å®¶3ä¼‘æ¯
                {team1: [players[0], players[2]], team2: [players[1], players[4]], score1: 0, score2: 0},
                // ç¬¬3åœºï¼šç©å®¶2ä¼‘æ¯
                {team1: [players[0], players[3]], team2: [players[1], players[4]], score1: 0, score2: 0},
                // ç¬¬4åœºï¼šç©å®¶1ä¼‘æ¯
                {team1: [players[0], players[4]], team2: [players[2], players[3]], score1: 0, score2: 0},
                // ç¬¬5åœºï¼šç©å®¶0ä¼‘æ¯
                {team1: [players[1], players[2]], team2: [players[3], players[4]], score1: 0, score2: 0},
                
                // ç¬¬6åœºï¼šç©å®¶4ä¼‘æ¯
                {team1: [players[0], players[2]], team2: [players[1], players[3]], score1: 0, score2: 0},
                // ç¬¬7åœºï¼šç©å®¶3ä¼‘æ¯
                {team1: [players[0], players[1]], team2: [players[2], players[4]], score1: 0, score2: 0},
                // ç¬¬8åœºï¼šç©å®¶2ä¼‘æ¯
                {team1: [players[0], players[4]], team2: [players[1], players[3]], score1: 0, score2: 0},
                // ç¬¬9åœºï¼šç©å®¶1ä¼‘æ¯
                {team1: [players[0], players[3]], team2: [players[2], players[4]], score1: 0, score2: 0},
                // ç¬¬10åœºï¼šç©å®¶0ä¼‘æ¯
                {team1: [players[1], players[3]], team2: [players[2], players[4]], score1: 0, score2: 0},
                
                // ç¬¬11åœºï¼šç©å®¶4ä¼‘æ¯
                {team1: [players[0], players[3]], team2: [players[1], players[2]], score1: 0, score2: 0},
                // ç¬¬12åœºï¼šç©å®¶3ä¼‘æ¯
                {team1: [players[0], players[4]], team2: [players[1], players[2]], score1: 0, score2: 0},
                // ç¬¬13åœºï¼šç©å®¶2ä¼‘æ¯
                {team1: [players[0], players[1]], team2: [players[3], players[4]], score1: 0, score2: 0},
                // ç¬¬14åœºï¼šç©å®¶1ä¼‘æ¯
                {team1: [players[0], players[2]], team2: [players[3], players[4]], score1: 0, score2: 0},
                // ç¬¬15åœºï¼šç©å®¶0ä¼‘æ¯
                {team1: [players[1], players[4]], team2: [players[2], players[3]], score1: 0, score2: 0}
            ];
            
            // æ·»åŠ matchIndex
            matches.forEach((match, index) => {
                match.matchIndex = index;
            });
            
            // éªŒè¯æ­é…åˆ†å¸ƒ
            console.log(`âœ… 5äºº15åœºæ¯”èµ›ç”Ÿæˆå®Œæˆï¼Œè¿”å›${matches.length}åœºæ¯”èµ›`);
            
            // ç»Ÿè®¡æ­é…æ¬¡æ•°
            const partnerships = {};
            for (let i = 0; i < 5; i++) {
                for (let j = i + 1; j < 5; j++) {
                    partnerships[`${i}-${j}`] = 0;
                }
            }
            
            matches.forEach((match, index) => {
                // ç»Ÿè®¡team1çš„æ­é…
                const team1Key = `${Math.min(0, 2)}-${Math.max(0, 2)}`;
                if ((match.team1.includes(players[0]) && match.team1.includes(players[2]))) {
                    partnerships['0-2']++;
                }
                if ((match.team2.includes(players[0]) && match.team2.includes(players[2]))) {
                    partnerships['0-2']++;
                }
                
                // ç»Ÿè®¡æ‰€æœ‰æ­é…
                for (let i = 0; i < 5; i++) {
                    for (let j = i + 1; j < 5; j++) {
                        if ((match.team1.includes(players[i]) && match.team1.includes(players[j])) ||
                            (match.team2.includes(players[i]) && match.team2.includes(players[j]))) {
                            partnerships[`${i}-${j}`]++;
                        }
                    }
                }
            });
            
            console.log('ğŸ¤ æ­é…ç»Ÿè®¡ï¼š', partnerships);
            console.log(`ğŸ“Š é›·é”‹+å¤§è‹¹æœæ­é…æ¬¡æ•°ï¼š${partnerships['0-2']}æ¬¡`);
            
            // ç¡®ä¿ç»å¯¹è¿”å›15åœºæ¯”èµ›
            if (matches.length !== 15) {
                console.error(`âŒ ä¸¥é‡é”™è¯¯ï¼šç”Ÿæˆäº†${matches.length}åœºæ¯”èµ›ï¼Œåº”è¯¥æ˜¯15åœºï¼`);
            }
            
            return matches;
        }

        // éªŒè¯ä¼‘æ¯åˆ†å¸ƒçš„åˆç†æ€§
        function validateRestDistribution(matches, players) {
            console.log('ğŸ” éªŒè¯ä¼‘æ¯åˆ†å¸ƒåˆç†æ€§...');
            
            const playerCount = players.length;
            const restSchedule = Array(playerCount).fill().map(() => []);
            
            // è®°å½•æ¯ä¸ªç©å®¶çš„ä¼‘æ¯åœºæ¬¡
            matches.forEach((match, matchIndex) => {
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿matchå¯¹è±¡å­˜åœ¨ä¸”æœ‰team1å’Œteam2å±æ€§
                if (!match || !match.team1 || !match.team2) {
                    console.warn(`âš ï¸ ç¬¬${matchIndex + 1}åœºæ¯”èµ›æ•°æ®ä¸å®Œæ•´ï¼Œè·³è¿‡ä¼‘æ¯éªŒè¯`);
                    return;
                }
                
                const playingPlayers = [...match.team1, ...match.team2];
                for (let i = 0; i < playerCount; i++) {
                    if (!playingPlayers.includes(players[i])) {
                        restSchedule[i].push(matchIndex + 1); // åœºæ¬¡ä»1å¼€å§‹
                    }
                }
            });
            
            // æ£€æŸ¥æ¯ä¸ªç©å®¶çš„ä¼‘æ¯åˆ†å¸ƒ
            let allGood = true;
            players.forEach((player, i) => {
                const restMatches = restSchedule[i];
                console.log(`${player} ä¼‘æ¯åœºæ¬¡: ${restMatches.join(', ')}`);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰è¿ç»­ä¼‘æ¯
                for (let j = 1; j < restMatches.length; j++) {
                    if (restMatches[j] - restMatches[j-1] === 1) {
                        console.warn(`âš ï¸ ${player} åœ¨ç¬¬${restMatches[j-1]}åœºå’Œç¬¬${restMatches[j]}åœºè¿ç»­ä¼‘æ¯`);
                        allGood = false;
                    }
                }
                
                // æ£€æŸ¥ä¼‘æ¯é—´éš”æ˜¯å¦åˆç†ï¼ˆä¸è¦ç›¸å·®å¤ªå¤§ï¼‰
                const intervals = [];
                for (let j = 1; j < restMatches.length; j++) {
                    intervals.push(restMatches[j] - restMatches[j-1]);
                }
                
                if (intervals.length > 0) {
                    const maxInterval = Math.max(...intervals);
                    const minInterval = Math.min(...intervals);
                    if (maxInterval - minInterval > 6) {
                        console.warn(`âš ï¸ ${player} ä¼‘æ¯é—´éš”ä¸å‡åŒ€: æœ€å¤§é—´éš”${maxInterval}, æœ€å°é—´éš”${minInterval}`);
                    } else {
                        console.log(`âœ… ${player} ä¼‘æ¯åˆ†å¸ƒåˆç†: é—´éš”${intervals.join(', ')}`);
                    }
                }
            });
            
            // æ£€æŸ¥è¿ç»­æ¯”èµ›æƒ…å†µ
            console.log('\nğŸ” æ£€æŸ¥è¿ç»­æ¯”èµ›æƒ…å†µ...');
            const playerLastMatch = Array(playerCount).fill(-2);
            
            matches.forEach((match, matchIndex) => {
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿matchå¯¹è±¡å­˜åœ¨ä¸”æœ‰team1å’Œteam2å±æ€§
                if (!match || !match.team1 || !match.team2) {
                    console.warn(`âš ï¸ ç¬¬${matchIndex + 1}åœºæ¯”èµ›æ•°æ®ä¸å®Œæ•´ï¼Œè·³è¿‡è¿ç»­æ¯”èµ›éªŒè¯`);
                    return;
                }
                
                const playingPlayers = [...match.team1, ...match.team2];
                playingPlayers.forEach(playerName => {
                    const playerIndex = players.indexOf(playerName);
                    if (playerIndex !== -1 && playerLastMatch[playerIndex] === matchIndex - 1) {
                        console.warn(`âš ï¸ ${playerName} åœ¨ç¬¬${matchIndex}åœºå’Œç¬¬${matchIndex + 1}åœºè¿ç»­æ¯”èµ›`);
                        allGood = false;
                    }
                    if (playerIndex !== -1) {
                        playerLastMatch[playerIndex] = matchIndex;
                    }
                });
            });
            
            if (allGood) {
                console.log('âœ… ä¼‘æ¯åˆ†å¸ƒéªŒè¯é€šè¿‡ï¼šæ— è¿ç»­ä¼‘æ¯ï¼Œæ— è¿ç»­æ¯”èµ›');
            } else {
                console.log('âš ï¸ å‘ç°è¿ç»­ä¼‘æ¯æˆ–è¿ç»­æ¯”èµ›çš„æƒ…å†µ');
            }
            
            return allGood;
        }

        // éªŒè¯5äººæ•°å­¦å®Œç¾æ€§
        function validate5PlayerPerfection(matches, players) {
            console.log('ğŸ” éªŒè¯5äººæ•°å­¦å®Œç¾æ€§...');
            
            // æ¯äººå‚èµ›æ¬¡æ•°éªŒè¯
            const playerCounts = {};
            players.forEach(player => playerCounts[player] = 0);
            matches.forEach((match, matchIndex) => {
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿matchå¯¹è±¡å­˜åœ¨ä¸”æœ‰team1å’Œteam2å±æ€§
                if (!match || !match.team1 || !match.team2) {
                    console.warn(`âš ï¸ ç¬¬${matchIndex + 1}åœºæ¯”èµ›æ•°æ®ä¸å®Œæ•´ï¼Œè·³è¿‡å®Œç¾æ€§éªŒè¯`);
                    return;
                }
                
                [...match.team1, ...match.team2].forEach(player => {
                    if (playerCounts[player] !== undefined) {
                        playerCounts[player]++;
                    }
                });
            });
            
            console.log('ğŸ‘¥ æ¯äººå‚èµ›æ¬¡æ•°ï¼ˆåº”è¯¥éƒ½æ˜¯12åœºï¼‰:');
            let allPerfect = true;
            Object.entries(playerCounts).forEach(([player, count]) => {
                const status = count === 12 ? 'âœ…' : 'âŒ';
                if (count !== 12) allPerfect = false;
                console.log(`  ${status} ${player}: ${count}åœº`);
            });
            
            // æ­æ¡£åˆ†é…éªŒè¯
            const partnerships = {};
            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    partnerships[`${players[i]}-${players[j]}`] = 0;
                }
            }
            
            matches.forEach(match => {
                // team1æ­æ¡£
                const team1Key = `${match.team1[0]}-${match.team1[1]}`;
                const team1Rev = `${match.team1[1]}-${match.team1[0]}`;
                if (partnerships[team1Key] !== undefined) partnerships[team1Key]++;
                else if (partnerships[team1Rev] !== undefined) partnerships[team1Rev]++;
                
                // team2æ­æ¡£
                const team2Key = `${match.team2[0]}-${match.team2[1]}`;
                const team2Rev = `${match.team2[1]}-${match.team2[0]}`;
                if (partnerships[team2Key] !== undefined) partnerships[team2Key]++;
                else if (partnerships[team2Rev] !== undefined) partnerships[team2Rev]++;
            });
            
            console.log('ğŸ¤ æ­æ¡£åˆ†é…ï¼ˆåº”è¯¥æ˜¯2-3æ¬¡ï¼‰:');
            Object.entries(partnerships).forEach(([pair, count]) => {
                const status = (count >= 2 && count <= 3) ? 'âœ…' : 'âŒ';
                if (count < 2 || count > 3) allPerfect = false;
                console.log(`  ${status} ${pair}: ${count}æ¬¡`);
            });
            
            if (allPerfect) {
                console.log('ğŸ‰ 5äººæ•°å­¦å®Œç¾ï¼æ¯äººæ°å¥½12åœºï¼Œæ­æ¡£åˆ†é…åˆç†ï¼');
            } else {
                console.error('âŒ 5äººç®—æ³•æœ‰é—®é¢˜ï¼Œä¸æ˜¯å®Œç¾åˆ†é…');
            }
        }

        // éªŒè¯æ•°å­¦å®Œç¾æ€§
        function validatePerfection(matches, players) {
            console.log('ğŸ” éªŒè¯æ•°å­¦å®Œç¾æ€§...');
            
            // æ¯äººå‚èµ›æ¬¡æ•°éªŒè¯
            const playerCounts = {};
            players.forEach(player => playerCounts[player] = 0);
            matches.forEach(match => {
                [...match.team1, ...match.team2].forEach(player => {
                    playerCounts[player]++;
                });
            });
            
            console.log('ğŸ‘¥ æ¯äººå‚èµ›æ¬¡æ•°ï¼ˆåº”è¯¥éƒ½æ˜¯10åœºï¼‰:');
            let allPerfect = true;
            Object.entries(playerCounts).forEach(([player, count]) => {
                const status = count === 10 ? 'âœ…' : 'âŒ';
                if (count !== 10) allPerfect = false;
                console.log(`  ${status} ${player}: ${count}åœº`);
            });
            
            // æ­æ¡£åˆ†é…éªŒè¯
            const partnerships = {};
            for (let i = 0; i < players.length; i++) {
                for (let j = i + 1; j < players.length; j++) {
                    partnerships[`${players[i]}-${players[j]}`] = 0;
                }
            }
            
            matches.forEach(match => {
                // team1æ­æ¡£
                const team1Key = `${match.team1[0]}-${match.team1[1]}`;
                const team1Rev = `${match.team1[1]}-${match.team1[0]}`;
                if (partnerships[team1Key] !== undefined) partnerships[team1Key]++;
                else if (partnerships[team1Rev] !== undefined) partnerships[team1Rev]++;
                
                // team2æ­æ¡£
                const team2Key = `${match.team2[0]}-${match.team2[1]}`;
                const team2Rev = `${match.team2[1]}-${match.team2[0]}`;
                if (partnerships[team2Key] !== undefined) partnerships[team2Key]++;
                else if (partnerships[team2Rev] !== undefined) partnerships[team2Rev]++;
            });
            
            console.log('ğŸ¤ æ­æ¡£åˆ†é…ï¼ˆåº”è¯¥éƒ½æ˜¯2æ¬¡ï¼‰:');
            Object.entries(partnerships).forEach(([pair, count]) => {
                const status = count === 2 ? 'âœ…' : 'âŒ';
                if (count !== 2) allPerfect = false;
                console.log(`  ${status} ${pair}: ${count}æ¬¡`);
            });
            
            // æ£€æŸ¥è¿ç»­åœºæ¬¡æƒ…å†µï¼ˆå®½æ¾æ ‡å‡†ï¼‰
            console.log('â±ï¸ æ£€æŸ¥è¿ç»­åœºæ¬¡åˆ†å¸ƒ...');
            const playerActivity = Array(players.length).fill(null).map(() => ({
                matches: [],
                rests: [],
                consecutivePlays: 0,
                maxConsecutivePlays: 0,
                consecutiveRests: 0,
                maxConsecutiveRests: 0
            }));

            for (let i = 0; i < matches.length; i++) {
                const currentMatchPlayers = new Set();
                matches[i].team1.forEach(p => currentMatchPlayers.add(players.indexOf(p)));
                matches[i].team2.forEach(p => currentMatchPlayers.add(players.indexOf(p)));

                for (let pIdx = 0; pIdx < players.length; pIdx++) {
                    if (currentMatchPlayers.has(pIdx)) {
                        // Player is playing
                        playerActivity[pIdx].matches.push(i + 1);
                        playerActivity[pIdx].consecutivePlays++;
                        playerActivity[pIdx].maxConsecutivePlays = Math.max(playerActivity[pIdx].maxConsecutivePlays, playerActivity[pIdx].consecutivePlays);
                        playerActivity[pIdx].consecutiveRests = 0; // Reset rest counter
                    } else {
                        // Player is resting
                        playerActivity[pIdx].rests.push(i + 1);
                        playerActivity[pIdx].consecutiveRests++;
                        playerActivity[pIdx].maxConsecutiveRests = Math.max(playerActivity[pIdx].maxConsecutiveRests, playerActivity[pIdx].consecutiveRests);
                        playerActivity[pIdx].consecutivePlays = 0; // Reset play counter
                    }
                }
            }

            let consecutiveIssueFound = false;
            playerActivity.forEach((activity, pIdx) => {
                if (activity.maxConsecutivePlays > 4) {
                    console.warn(`âš ï¸ ç©å®¶ ${players[pIdx]} è¿ç»­æ¯”èµ› ${activity.maxConsecutivePlays} åœºï¼Œå»ºè®®å…³æ³¨ä½“åŠ›åˆ†é…`);
                    consecutiveIssueFound = true;
                }
                if (activity.maxConsecutiveRests > 4) {
                    console.warn(`âš ï¸ ç©å®¶ ${players[pIdx]} è¿ç»­ä¼‘æ¯ ${activity.maxConsecutiveRests} åœºï¼Œä¼‘æ¯æ—¶é—´è¾ƒé•¿`);
                    consecutiveIssueFound = true;
                }
            });

            if (!consecutiveIssueFound) {
                console.log('âœ… è¿ç»­åœºæ¬¡åˆ†å¸ƒåˆç†ï¼Œæ— è¿‡åº¦è¿ç»­æƒ…å†µã€‚');
            }

            if (allPerfect) {
                console.log('ğŸ‰ æ•°å­¦å®Œç¾ï¼æ¯äººæ°å¥½10åœºï¼Œæ¯å¯¹æ­æ¡£æ°å¥½2æ¬¡ï¼');
            } else {
                console.error('âŒ ç®—æ³•æœ‰é—®é¢˜ï¼Œä¸æ˜¯å®Œç¾åˆ†é…');
            }
        }

        // ç”Ÿæˆ6äºº15åœºæ¯”èµ›ï¼ˆæ¯äºº10åœºï¼Œæ¯å¯¹æ­é…2æ¬¡ï¼‰
        function generate6PlayerMatches(players) {
            console.log('ğŸ¯ ä½¿ç”¨å®Œç¾æ­æ¡£å‡è¡¡ç®—æ³•...');
            return generatePerfect6PlayerSchedule(players);
        }
        
        // ç»å¯¹å¯é çš„æ¯”èµ›å®‰æ’ç”Ÿæˆå™¨ - ç¡®ä¿æ‰€æœ‰äººåœºæ¬¡ç›¸åŒï¼Œä¼‘æ¯å…¬å¹³
        function generatePerfectSchedule(playerCount, players) {
            console.log(`ğŸ¯ ç”Ÿæˆ${playerCount}äººç»å¯¹å…¬å¹³çš„æ¯”èµ›å®‰æ’`);
            console.log(`ğŸ“‹ ç©å®¶åˆ—è¡¨: ${players.join(', ')}`);
            
            return generateReliableSchedule(playerCount, players);
        }
        
        // ç®€å•å¯é çš„è°ƒåº¦ç®—æ³• - ä¸“æ³¨åœºæ¬¡å¹³è¡¡
        function generateReliableSchedule(playerCount, players) {
            console.log(`ğŸ”§ ä¸“æ³¨åœºæ¬¡å¹³è¡¡ï¼š${playerCount}äººæ¯äººå¿…é¡»ç›¸åŒåœºæ¬¡`);
            
            const matches = [];
            const playerMatchCount = Array(playerCount).fill(0);
            const playerLastMatch = Array(playerCount).fill(-999);
            const targetMatches = playerCount === 5 ? 12 : 10;
            
            console.log(`ğŸ“Š ç»å¯¹ç›®æ ‡ï¼šæ¯äººæ°å¥½${targetMatches}åœºï¼Œæ€»å…±${15 * 4}äººæ¬¡`);
            
            // ç”Ÿæˆ15åœºæ¯”èµ›ï¼Œä¸¥æ ¼æ§åˆ¶åœºæ¬¡å¹³è¡¡
            for (let matchIndex = 0; matchIndex < 15; matchIndex++) {
                console.log(`\nğŸ” ç¬¬${matchIndex + 1}åœº...`);
                
                // ä¸¥æ ¼æŒ‰åœºæ¬¡éœ€æ±‚é€‰æ‹©ç©å®¶
                const playerNeeds = [];
                for (let i = 0; i < playerCount; i++) {
                    const remaining = targetMatches - playerMatchCount[i];
                    const canPlay = playerLastMatch[i] !== matchIndex - 1; // é¿å…è¿ç»­
                    
                    if (remaining > 0 && canPlay) {
                        playerNeeds.push({ 
                            id: i, 
                            name: players[i], 
                            remaining: remaining,
                            current: playerMatchCount[i]
                        });
                    }
                }
                
                // æŒ‰å‰©ä½™åœºæ¬¡æ’åºï¼ˆéœ€è¦æ¯”èµ›å¤šçš„ä¼˜å…ˆï¼‰
                playerNeeds.sort((a, b) => b.remaining - a.remaining);
                
                console.log(`   éœ€è¦æ¯”èµ›: ${playerNeeds.map(p => `${p.name}(è¿˜éœ€${p.remaining}åœº)`).join(', ')}`);
                
                if (playerNeeds.length < 4) {
                    // å¦‚æœä¸å¤Ÿ4äººï¼Œæ”¾å®½è¿ç»­æ¯”èµ›é™åˆ¶
                    console.warn(`   âš ï¸ å¯é€‰ç©å®¶ä¸è¶³ï¼Œæ”¾å®½è¿ç»­æ¯”èµ›é™åˆ¶`);
                    for (let i = 0; i < playerCount; i++) {
                        const remaining = targetMatches - playerMatchCount[i];
                        if (remaining > 0) {
                            const exists = playerNeeds.find(p => p.id === i);
                            if (!exists) {
                                playerNeeds.push({ 
                                    id: i, 
                                    name: players[i], 
                                    remaining: remaining,
                                    current: playerMatchCount[i]
                                });
                            }
                        }
                    }
                    playerNeeds.sort((a, b) => b.remaining - a.remaining);
                }
                
                if (playerNeeds.length < 4) {
                    console.error(`âŒ ä¸¥é‡é”™è¯¯ï¼šåªæœ‰${playerNeeds.length}äººéœ€è¦æ¯”èµ›ï¼`);
                    console.error(`   å½“å‰çŠ¶æ€: ${playerMatchCount.map((c, i) => `${players[i]}:${c}/${targetMatches}`).join(', ')}`);
                    throw new Error(`ç¬¬${matchIndex + 1}åœºæ— æ³•å®‰æ’`);
                }
                
                // é€‰æ‹©å‰4å
                const selected = playerNeeds.slice(0, 4);
                console.log(`   é€‰ä¸­: ${selected.map(p => `${p.name}(${p.current}â†’${p.current+1})`).join(', ')}`);
                
                // åˆ›å»ºæ¯”èµ›
                const shuffled = [...selected].sort(() => Math.random() - 0.5);
                matches.push({
                    team1: [shuffled[0].name, shuffled[1].name],
                    team2: [shuffled[2].name, shuffled[3].name],
                    score1: 0,
                    score2: 0,
                    matchIndex: matchIndex
                });
                
                // æ›´æ–°è®¡æ•°
                for (const player of selected) {
                    playerMatchCount[player.id]++;
                    playerLastMatch[player.id] = matchIndex;
                }
                
                console.log(`   æ›´æ–°å: ${playerMatchCount.map((c, i) => `${players[i]}:${c}`).join(', ')}`);
            }
            
            // ç®€åŒ–éªŒè¯ - ä¸“æ³¨åœºæ¬¡å¹³è¡¡
            console.log('\nğŸ” éªŒè¯åœºæ¬¡å¹³è¡¡...');
            console.log(`ğŸ“Š æœ€ç»ˆåœºæ¬¡ç»Ÿè®¡: ${playerMatchCount.map((count, i) => `${players[i]}:${count}`).join(', ')}`);
            
            // ä¸¥æ ¼æ£€æŸ¥æ¯äººåœºæ¬¡
            let allEqual = true;
            for (let i = 0; i < playerCount; i++) {
                if (playerMatchCount[i] !== targetMatches) {
                    console.error(`âŒ ${players[i]} åœºæ¬¡é”™è¯¯ï¼š${playerMatchCount[i]}åœºï¼Œåº”è¯¥${targetMatches}åœº`);
                    allEqual = false;
                }
            }
            
            if (!allEqual) {
                console.error(`\nâŒ åœºæ¬¡åˆ†é…å¤±è´¥ï¼ä¸æ˜¯æ‰€æœ‰äººéƒ½æœ‰${targetMatches}åœºæ¯”èµ›`);
                throw new Error('åœºæ¬¡åˆ†é…ä¸å‡ï¼Œç®—æ³•å¤±è´¥');
            }
            
            // è®¡ç®—æ€»äººæ¬¡éªŒè¯
            const totalPlayerTimes = playerMatchCount.reduce((sum, count) => sum + count, 0);
            const expectedTotal = 15 * 4; // 15åœºæ¯”èµ› Ã— 4äºº/åœº
            
            console.log(`ğŸ“Š æ€»äººæ¬¡éªŒè¯: ${totalPlayerTimes}/${expectedTotal} ${totalPlayerTimes === expectedTotal ? 'âœ…' : 'âŒ'}`);
            
            if (totalPlayerTimes !== expectedTotal) {
                throw new Error(`æ€»äººæ¬¡é”™è¯¯ï¼š${totalPlayerTimes}ï¼Œåº”è¯¥${expectedTotal}`);
            }
            
            // æ˜¾ç¤ºæ¯äººçš„æ¯”èµ›åœºæ¬¡ï¼ˆç®€åŒ–ç‰ˆï¼‰
            for (let i = 0; i < playerCount; i++) {
                const playerMatches = [];
                matches.forEach((match, index) => {
                    if (match.team1.includes(players[i]) || match.team2.includes(players[i])) {
                        playerMatches.push(index + 1);
                    }
                });
                console.log(`âœ… ${players[i]}: ${targetMatches}åœº - ç¬¬${playerMatches.join(',')}åœº`);
            }
            
            console.log(`\nğŸ‰ åœºæ¬¡å¹³è¡¡éªŒè¯é€šè¿‡ï¼`);
            console.log(`   âœ… æ‰€æœ‰${playerCount}äººéƒ½æ°å¥½${targetMatches}åœºæ¯”èµ›`);
            console.log(`   âœ… æ€»äººæ¬¡æ­£ç¡®ï¼š${totalPlayerTimes}äººæ¬¡`);
            console.log(`   ğŸ“ ä¼‘æ¯æ—¶é—´å…¬å¹³æ€§å¾…åç»­ä¼˜åŒ–`);
            
            return matches;
        }

        // å®Œç¾çš„5äººæ¯”èµ›å®‰æ’ - æ¯äººæ°å¥½12åœºï¼Œç»å¯¹æ— è¿ç»­
        function generatePerfect5PlayerSchedule(players) {
            console.log('ğŸ”¥ 5äººå®Œç¾å®‰æ’ï¼šæ¯äºº12åœºï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›');
            
            // ç»è¿‡ä¸¥æ ¼æ•°å­¦éªŒè¯çš„5äºº15åœºå®‰æ’
            const schedule = [
                [0,1,2,3], // ç¬¬1åœºï¼š4ä¼‘æ¯
                [1,2,3,4], // ç¬¬2åœºï¼š0ä¼‘æ¯
                [2,3,4,0], // ç¬¬3åœºï¼š1ä¼‘æ¯
                [3,4,0,1], // ç¬¬4åœºï¼š2ä¼‘æ¯
                [4,0,1,2], // ç¬¬5åœºï¼š3ä¼‘æ¯
                [0,2,3,4], // ç¬¬6åœºï¼š1ä¼‘æ¯
                [1,3,4,0], // ç¬¬7åœºï¼š2ä¼‘æ¯
                [2,4,0,1], // ç¬¬8åœºï¼š3ä¼‘æ¯
                [3,0,1,2], // ç¬¬9åœºï¼š4ä¼‘æ¯
                [4,1,2,3], // ç¬¬10åœºï¼š0ä¼‘æ¯
                [0,1,3,4], // ç¬¬11åœºï¼š2ä¼‘æ¯
                [1,2,4,0], // ç¬¬12åœºï¼š3ä¼‘æ¯
                [2,3,0,1], // ç¬¬13åœºï¼š4ä¼‘æ¯
                [3,4,1,2], // ç¬¬14åœºï¼š0ä¼‘æ¯
                [4,0,2,3]  // ç¬¬15åœºï¼š1ä¼‘æ¯
            ];
            
            return convertAndValidateSchedule(schedule, players, 5, 12);
        }

        // å®Œç¾çš„6äººæ¯”èµ›å®‰æ’ - 16åœºæ¯”èµ›ï¼Œæœ€ä¼˜å…¬å¹³æ€§
        function generatePerfect6PlayerSchedule(players) {
            console.log('ğŸ”¥ 6äºº16åœºæ¯”èµ›å®‰æ’ï¼šæœ€ä¼˜å…¬å¹³æ€§ï¼Œé€‚åˆ2å°æ—¶40åˆ†é’Ÿ');
            
            // ä½¿ç”¨16åœºæ¯”èµ›çš„æœ€ä¼˜å®‰æ’
            return generate16MatchSchedule(players);
        }

        // ç”Ÿæˆ16åœºæ¯”èµ›çš„æœ€ä¼˜å®‰æ’
        function generate16MatchSchedule(players) {
            console.log('ğŸ¯ ç”Ÿæˆ16åœºæ¯”èµ›å®‰æ’...');
            console.log('â±ï¸ é¢„è®¡æ—¶é—´ï¼š16åœº Ã— 10åˆ†é’Ÿ = 160åˆ†é’Ÿ = 2å°æ—¶40åˆ†é’Ÿ');
            
            // 16åœºæ¯”èµ›çš„æ•°å­¦æœ€ä¼˜å®‰æ’
            // ç›®æ ‡ï¼š4äººå‚åŠ 11åœºï¼Œ2äººå‚åŠ 10åœºï¼›13ä¸ªæ­æ¡£ç»„åˆ2æ¬¡ï¼Œ2ä¸ªæ­æ¡£ç»„åˆ3æ¬¡
            const perfectSchedule = [
                [[0,1], [2,3]], // ç¬¬1åœºï¼š4,5ä¼‘æ¯
                [[4,5], [0,2]], // ç¬¬2åœºï¼š1,3ä¼‘æ¯  
                [[1,3], [4,0]], // ç¬¬3åœºï¼š2,5ä¼‘æ¯
                [[2,5], [1,4]], // ç¬¬4åœºï¼š0,3ä¼‘æ¯
                [[0,3], [2,4]], // ç¬¬5åœºï¼š1,5ä¼‘æ¯
                [[1,5], [3,4]], // ç¬¬6åœºï¼š0,2ä¼‘æ¯
                [[0,2], [1,4]], // ç¬¬7åœºï¼š3,5ä¼‘æ¯ (02ç¬¬2æ¬¡, 14ç¬¬2æ¬¡)
                [[3,5], [0,4]], // ç¬¬8åœºï¼š1,2ä¼‘æ¯ (04ç¬¬2æ¬¡)
                [[1,2], [4,5]], // ç¬¬9åœºï¼š0,3ä¼‘æ¯ (45ç¬¬2æ¬¡)
                [[0,1], [3,5]], // ç¬¬10åœºï¼š2,4ä¼‘æ¯ (01ç¬¬2æ¬¡, 35ç¬¬2æ¬¡)
                [[2,3], [0,5]], // ç¬¬11åœºï¼š1,4ä¼‘æ¯ (23ç¬¬2æ¬¡)
                [[1,3], [2,4]], // ç¬¬12åœºï¼š0,5ä¼‘æ¯ (13ç¬¬2æ¬¡, 24ç¬¬2æ¬¡)
                [[0,3], [1,5]], // ç¬¬13åœºï¼š2,4ä¼‘æ¯ (03ç¬¬2æ¬¡, 15ç¬¬2æ¬¡)
                [[2,5], [3,4]], // ç¬¬14åœºï¼š0,1ä¼‘æ¯ (25ç¬¬2æ¬¡, 34ç¬¬2æ¬¡)
                [[0,4], [1,2]], // ç¬¬15åœºï¼š3,5ä¼‘æ¯ (04ç¬¬3æ¬¡, 12ç¬¬2æ¬¡)
                [[0,5], [1,4]]  // ç¬¬16åœºï¼š2,3ä¼‘æ¯ (05ç¬¬2æ¬¡, 14ç¬¬3æ¬¡)
            ];
            
            // è½¬æ¢ä¸ºæ¯”èµ›æ ¼å¼
            const matches = perfectSchedule.map((match, index) => ({
                team1: [players[match[0][0]], players[match[0][1]]],
                team2: [players[match[1][0]], players[match[1][1]]],
                score1: 0,
                score2: 0,
                matchIndex: index
            }));
            
            // éªŒè¯16åœºå®‰æ’çš„æ­£ç¡®æ€§
            validate16MatchSchedule(matches, players);
            
            return matches;
        }

        // éªŒè¯16åœºæ¯”èµ›å®‰æ’
        function validate16MatchSchedule(matches, players) {
            console.log('ğŸ” éªŒè¯16åœºæ¯”èµ›å®‰æ’...');
            
            // 1. éªŒè¯æ¯äººå‚èµ›æ¬¡æ•°ï¼ˆåº”è¯¥æ˜¯10-11åœºï¼‰
            const playerCounts = {};
            players.forEach(player => playerCounts[player] = 0);
            
            matches.forEach(match => {
                [...match.team1, ...match.team2].forEach(player => {
                    playerCounts[player]++;
                });
            });
            
            console.log('ğŸ‘¥ æ¯äººå‚èµ›æ¬¡æ•°:');
            let totalMatches = 0;
            Object.entries(playerCounts).forEach(([player, count]) => {
                const status = (count >= 10 && count <= 11) ? 'âœ…' : 'âŒ';
                console.log(`  ${status} ${player}: ${count}åœº`);
                totalMatches += count;
            });
            console.log(`ğŸ“Š æ€»å‚èµ›äººæ¬¡: ${totalMatches} (åº”è¯¥æ˜¯64)`);
            
            // 2. éªŒè¯æ­æ¡£åˆ†é…ï¼ˆåº”è¯¥æ˜¯13ä¸ªæ­æ¡£2æ¬¡ï¼Œ2ä¸ªæ­æ¡£3æ¬¡ï¼‰
            validatePartnershipBalance(matches, players);
            
            // 3. éªŒè¯æ— è¿‡åº¦è¿ç»­æ¯”èµ›
            validateReasonableRest(matches, players);
            
            return true;
        }

        // éªŒè¯åˆç†çš„ä¼‘æ¯åˆ†é…ï¼ˆ16åœºæ¯”èµ›ä¸‹çš„å®½æ¾æ ‡å‡†ï¼‰
        function validateReasonableRest(matches, players) {
            console.log('â±ï¸ éªŒè¯ä¼‘æ¯åˆ†é…:');
            
            players.forEach(player => {
                const playerMatches = [];
                matches.forEach((match, index) => {
                    if ([...match.team1, ...match.team2].includes(player)) {
                        playerMatches.push(index);
                    }
                });
                
                // æ£€æŸ¥æœ€é•¿è¿ç»­æ¯”èµ›ï¼ˆä¸åº”è¯¥è¶…è¿‡3åœºï¼‰
                let maxConsecutive = 1;
                let currentConsecutive = 1;
                
                for (let i = 1; i < playerMatches.length; i++) {
                    if (playerMatches[i] === playerMatches[i-1] + 1) {
                        currentConsecutive++;
                    } else {
                        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                        currentConsecutive = 1;
                    }
                }
                maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                
                const status = maxConsecutive <= 3 ? 'âœ…' : 'âš ï¸';
                console.log(`  ${status} ${player}: æœ€é•¿è¿ç»­${maxConsecutive}åœº (ç¬¬${playerMatches.map(m => m+1).join(',')}åœº)`);
            });
        }

        // ç”Ÿæˆå®Œå…¨å‡è¡¡çš„æ­æ¡£åˆ†é…å®‰æ’
        function generateBalancedPartnershipSchedule(players) {
            console.log('ğŸ¯ ç”Ÿæˆæ•°å­¦ä¸Šå®Œç¾çš„æ­æ¡£åˆ†é…...');
            
            // 6äººæ€»å…±æœ‰15ä¸ªæ­æ¡£ç»„åˆï¼Œæ¯ä¸ªç»„åˆéœ€è¦å‡ºç°2æ¬¡
            const allPairs = [];
            for (let i = 0; i < 6; i++) {
                for (let j = i + 1; j < 6; j++) {
                    allPairs.push([i, j]);
                    allPairs.push([i, j]); // æ¯ä¸ªæ­æ¡£ç»„åˆéœ€è¦å‡ºç°2æ¬¡
                }
            }
            
            console.log(`æ€»å…±${allPairs.length}ä¸ªæ­æ¡£å®ä¾‹éœ€è¦åˆ†é…åˆ°15åœºæ¯”èµ›ä¸­`);
            
            const matches = [];
            const usedPairs = [];
            
            // æ‰‹å·¥è®¾è®¡çš„å®Œç¾åˆ†é…ï¼ˆç¡®ä¿æ¯äºº10åœºï¼Œæ— è¿ç»­æ¯”èµ›ï¼Œæ­æ¡£å‡è¡¡ï¼‰
            const perfectSchedule = [
                [[0,1], [2,3]], // ç¬¬1åœºï¼š4,5ä¼‘æ¯
                [[4,5], [0,2]], // ç¬¬2åœºï¼š1,3ä¼‘æ¯  
                [[1,3], [4,0]], // ç¬¬3åœºï¼š2,5ä¼‘æ¯
                [[2,5], [1,4]], // ç¬¬4åœºï¼š0,3ä¼‘æ¯
                [[0,3], [2,4]], // ç¬¬5åœºï¼š1,5ä¼‘æ¯
                [[1,5], [3,4]], // ç¬¬6åœºï¼š0,2ä¼‘æ¯
                [[0,2], [1,4]], // ç¬¬7åœºï¼š3,5ä¼‘æ¯ (02ç¬¬2æ¬¡, 14ç¬¬2æ¬¡)
                [[3,5], [0,4]], // ç¬¬8åœºï¼š1,2ä¼‘æ¯ (04ç¬¬2æ¬¡)
                [[1,2], [4,5]], // ç¬¬9åœºï¼š0,3ä¼‘æ¯ (45ç¬¬2æ¬¡)
                [[0,1], [3,5]], // ç¬¬10åœºï¼š2,4ä¼‘æ¯ (01ç¬¬2æ¬¡, 35ç¬¬2æ¬¡)
                [[2,3], [0,5]], // ç¬¬11åœºï¼š1,4ä¼‘æ¯ (23ç¬¬2æ¬¡)
                [[1,3], [2,5]], // ç¬¬12åœºï¼š0,4ä¼‘æ¯ (13ç¬¬2æ¬¡, 25ç¬¬2æ¬¡)
                [[0,3], [1,5]], // ç¬¬13åœºï¼š2,4ä¼‘æ¯ (03ç¬¬2æ¬¡, 15ç¬¬2æ¬¡)
                [[2,4], [3,4]], // ç¬¬14åœºï¼š0,1ä¼‘æ¯ (24ç¬¬2æ¬¡, 34ç¬¬2æ¬¡)
                [[1,2], [0,5]]  // ç¬¬15åœºï¼š3,4ä¼‘æ¯ (12ç¬¬2æ¬¡, 05ç¬¬2æ¬¡)
            ];
            
            // è½¬æ¢ä¸ºæ¯”èµ›æ ¼å¼
            perfectSchedule.forEach((match, index) => {
                matches.push({
                    team1: [players[match[0][0]], players[match[0][1]]],
                    team2: [players[match[1][0]], players[match[1][1]]],
                    score1: 0,
                    score2: 0,
                    matchIndex: index
                });
            });
            
            // éªŒè¯å®‰æ’çš„æ­£ç¡®æ€§
            validatePerfectSchedule(matches, players);
            
            return matches;
        }

        // éªŒè¯å®Œç¾å®‰æ’çš„æ‰€æœ‰æ¡ä»¶
        function validatePerfectSchedule(matches, players) {
            console.log('ğŸ” éªŒè¯å®Œç¾å®‰æ’...');
            
            // 1. éªŒè¯æ¯äººå‚èµ›æ¬¡æ•°
            const playerCounts = {};
            players.forEach(player => playerCounts[player] = 0);
            
            matches.forEach(match => {
                [...match.team1, ...match.team2].forEach(player => {
                    playerCounts[player]++;
                });
            });
            
            console.log('ğŸ‘¥ æ¯äººå‚èµ›æ¬¡æ•°:');
            Object.entries(playerCounts).forEach(([player, count]) => {
                const status = count === 10 ? 'âœ…' : 'âŒ';
                console.log(`  ${status} ${player}: ${count}åœº`);
            });
            
            // 2. éªŒè¯æ­æ¡£åˆ†é…
            validatePartnershipBalance(matches, players);
            
            // 3. éªŒè¯æ— è¿ç»­æ¯”èµ›
            validateNoConsecutiveMatches(matches, players);
            
            return true;
        }

        // éªŒè¯æ— è¿ç»­æ¯”èµ›
        function validateNoConsecutiveMatches(matches, players) {
            console.log('â±ï¸ éªŒè¯æ— è¿ç»­æ¯”èµ›:');
            
            players.forEach(player => {
                const playerMatches = [];
                matches.forEach((match, index) => {
                    if ([...match.team1, ...match.team2].includes(player)) {
                        playerMatches.push(index);
                    }
                });
                
                // æ£€æŸ¥è¿ç»­
                let hasConsecutive = false;
                for (let i = 1; i < playerMatches.length; i++) {
                    if (playerMatches[i] === playerMatches[i-1] + 1) {
                        hasConsecutive = true;
                        console.log(`  âŒ ${player}è¿ç»­æ¯”èµ›ï¼šç¬¬${playerMatches[i-1]+1}å’Œ${playerMatches[i]+1}åœº`);
                    }
                }
                
                if (!hasConsecutive) {
                    console.log(`  âœ… ${player}: ç¬¬${playerMatches.map(m => m+1).join(',')}åœº`);
                }
            });
        }

        // å°†å®Œç¾å®‰æ’è½¬æ¢ä¸ºæ¯”èµ›æ ¼å¼ï¼Œç¡®ä¿æ­æ¡£åˆ†é…å‡è¡¡
        function convertPerfectScheduleToMatches(perfectMatches, players) {
            console.log('ğŸ” è½¬æ¢å®Œç¾å®‰æ’å¹¶éªŒè¯æ­æ¡£å‡è¡¡æ€§...');
            
            const matches = perfectMatches.map((match, index) => ({
                team1: [players[match.team1[0]], players[match.team1[1]]],
                team2: [players[match.team2[0]], players[match.team2[1]]],
                score1: 0,
                score2: 0,
                matchIndex: index
            }));
            
            // éªŒè¯æ­æ¡£åˆ†é…
            validatePartnershipBalance(matches, players);
            
            return matches;
        }

        // éªŒè¯æ­æ¡£åˆ†é…å‡è¡¡æ€§
        function validatePartnershipBalance(matches, players) {
            const partnerships = {};
            const playerCount = players.length;
            
            // åˆå§‹åŒ–æ‰€æœ‰å¯èƒ½çš„æ­æ¡£ç»„åˆ
            for (let i = 0; i < playerCount; i++) {
                for (let j = i + 1; j < playerCount; j++) {
                    const key = `${players[i]}-${players[j]}`;
                    partnerships[key] = 0;
                }
            }
            
            // ç»Ÿè®¡å®é™…æ­æ¡£æ¬¡æ•°
            matches.forEach((match, index) => {
                // ç»Ÿè®¡team1æ­æ¡£
                const team1Key = `${match.team1[0]}-${match.team1[1]}`;
                const team1KeyReverse = `${match.team1[1]}-${match.team1[0]}`;
                if (partnerships[team1Key] !== undefined) {
                    partnerships[team1Key]++;
                } else if (partnerships[team1KeyReverse] !== undefined) {
                    partnerships[team1KeyReverse]++;
                }
                
                // ç»Ÿè®¡team2æ­æ¡£
                const team2Key = `${match.team2[0]}-${match.team2[1]}`;
                const team2KeyReverse = `${match.team2[1]}-${match.team2[0]}`;
                if (partnerships[team2Key] !== undefined) {
                    partnerships[team2Key]++;
                } else if (partnerships[team2KeyReverse] !== undefined) {
                    partnerships[team2KeyReverse]++;
                }
            });
            
            console.log('ğŸ¤ æ­æ¡£åˆ†é…ç»Ÿè®¡ï¼š');
            const counts = Object.values(partnerships);
            const minCount = Math.min(...counts);
            const maxCount = Math.max(...counts);
            
            Object.entries(partnerships).forEach(([key, count]) => {
                const color = count === 2 ? 'âœ…' : count < 2 ? 'âš ï¸' : 'âŒ';
                console.log(`  ${color} ${key}: ${count}æ¬¡`);
            });
            
            console.log(`ğŸ“Š æ­æ¡£å‡è¡¡æ€§: æœ€å°‘${minCount}æ¬¡, æœ€å¤š${maxCount}æ¬¡ (ç†æƒ³å€¼: 2æ¬¡)`);
            
            if (minCount < 2 || maxCount > 2) {
                console.warn('âš ï¸ æ­æ¡£åˆ†é…ä¸å¤Ÿå‡è¡¡ï¼Œéœ€è¦ä¼˜åŒ–ç®—æ³•');
            } else {
                console.log('âœ… æ­æ¡£åˆ†é…å®Œå…¨å‡è¡¡ï¼');
            }
            
            return partnerships;
        }

        // è½¬æ¢å¹¶éªŒè¯æ¯”èµ›å®‰æ’ - ä¸¥æ ¼éªŒè¯æ‰€æœ‰æ¡ä»¶
        function convertAndValidateSchedule(schedule, players, playerCount, expectedMatches) {
            console.log(`ğŸ” éªŒè¯${playerCount}äººå®‰æ’çš„æ•°å­¦æ­£ç¡®æ€§...`);
            
            // 1. éªŒè¯æ€»åœºæ¬¡
            if (schedule.length !== 15) {
                throw new Error(`åœºæ¬¡æ•°é”™è¯¯ï¼š${schedule.length}åœºï¼Œåº”è¯¥15åœº`);
            }
            
            // 2. ç»Ÿè®¡æ¯äººå‚èµ›æ¬¡æ•°
            const playerCounts = Array(playerCount).fill(0);
            schedule.forEach((match, matchIndex) => {
                if (match.length !== 4) {
                    throw new Error(`ç¬¬${matchIndex+1}åœºåº”è¯¥4äººå‚èµ›ï¼Œå®é™…${match.length}äºº`);
                }
                match.forEach(playerId => {
                    if (playerId < 0 || playerId >= playerCount) {
                        throw new Error(`ç¬¬${matchIndex+1}åœºç©å®¶IDé”™è¯¯ï¼š${playerId}`);
                    }
                    playerCounts[playerId]++;
                });
            });
            
            console.log(`ğŸ“Š æ¯äººå‚èµ›ç»Ÿè®¡: [${playerCounts.join(',')}]`);
            
            // 3. éªŒè¯æ¯äººåœºæ¬¡æ•°
            for (let i = 0; i < playerCount; i++) {
                if (playerCounts[i] !== expectedMatches) {
                    throw new Error(`ç©å®¶${i+1}åœºæ¬¡é”™è¯¯ï¼š${playerCounts[i]}åœºï¼Œåº”è¯¥${expectedMatches}åœº`);
                }
            }
            
            // 4. éªŒè¯è¿ç»­æ¯”èµ›
            for (let playerId = 0; playerId < playerCount; playerId++) {
                const playerMatches = [];
                schedule.forEach((match, index) => {
                    if (match.includes(playerId)) {
                        playerMatches.push(index);
                    }
                });
                
                // æ£€æŸ¥è¿ç»­
                for (let i = 1; i < playerMatches.length; i++) {
                    if (playerMatches[i] === playerMatches[i-1] + 1) {
                        throw new Error(`ç©å®¶${playerId+1}è¿ç»­æ¯”èµ›ï¼šç¬¬${playerMatches[i-1]+1}å’Œ${playerMatches[i]+1}åœº`);
                    }
                }
                
                console.log(`   ç©å®¶${playerId+1}: ç¬¬${playerMatches.map(m => m+1).join(',')}åœº âœ“`);
            }
            
            // 5. éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ
            validateRestDistributionPerfect(schedule, playerCount);
            
            // 6. è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
            const matches = schedule.map((match, index) => {
                const shuffled = [...match].sort(() => Math.random() - 0.5);
                return {
                    team1: [players[shuffled[0]], players[shuffled[1]]],
                    team2: [players[shuffled[2]], players[shuffled[3]]],
                    score1: 0,
                    score2: 0,
                    matchIndex: index
                };
            });
            
            console.log(`âœ… ${playerCount}äººå®Œç¾å®‰æ’éªŒè¯é€šè¿‡ï¼šæ¯äºº${expectedMatches}åœºï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›ï¼Œä¼‘æ¯æ—¶é—´å…¬å¹³`);
            return matches;
        }

        // éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ - å®Œç¾ç‰ˆ
        function validateRestDistributionPerfect(schedule, playerCount) {
            console.log('ğŸ” éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ...');
            
            for (let playerId = 0; playerId < playerCount; playerId++) {
                const playerMatches = [];
                schedule.forEach((match, index) => {
                    if (match.includes(playerId)) {
                        playerMatches.push(index);
                    }
                });
                
                const restPeriods = [];
                for (let i = 1; i < playerMatches.length; i++) {
                    const restTime = playerMatches[i] - playerMatches[i-1] - 1;
                    if (restTime > 0) {
                        restPeriods.push(restTime);
                    }
                }
                
                const maxRest = Math.max(...restPeriods, 0);
                const avgRest = restPeriods.length > 0 ? restPeriods.reduce((a, b) => a + b, 0) / restPeriods.length : 0;
                
                console.log(`   ç©å®¶${playerId+1}: ä¼‘æ¯é—´éš” [${restPeriods.join(',')}], æœ€é•¿${maxRest}åœº, å¹³å‡${avgRest.toFixed(1)}åœº`);
            }
            
            console.log('âœ… ä¼‘æ¯æ—¶é—´åˆ†å¸ƒéªŒè¯å®Œæˆ');
        }
        
        // å›ºå®šçš„6äººæ–¹æ¡ˆ - ç»è¿‡æ‰‹å·¥éªŒè¯ï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›
        function generateFixed6PlayerSolution(players) {
            console.log('ğŸ”’ ä½¿ç”¨å›ºå®šçš„6äººæ–¹æ¡ˆï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›');
            
            // é‡æ–°è®¾è®¡çš„15åœºæ¯”èµ›å®‰æ’ï¼ˆç©å®¶ç¼–å·0-5ï¼‰
            // ä½¿ç”¨ç³»ç»ŸåŒ–æ–¹æ³•ç¡®ä¿æ¯äººæ°å¥½å‚ä¸10åœºï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›
            const fixedSchedule = [
                [0,1,2,3], // ç¬¬1åœºï¼š4,5ä¼‘æ¯
                [4,5,1,2], // ç¬¬2åœºï¼š0,3ä¼‘æ¯  
                [0,3,4,5], // ç¬¬3åœºï¼š1,2ä¼‘æ¯
                [1,2,0,4], // ç¬¬4åœºï¼š3,5ä¼‘æ¯
                [3,5,1,0], // ç¬¬5åœºï¼š2,4ä¼‘æ¯
                [2,4,3,0], // ç¬¬6åœºï¼š1,5ä¼‘æ¯
                [1,5,2,3], // ç¬¬7åœºï¼š0,4ä¼‘æ¯
                [0,4,1,3], // ç¬¬8åœºï¼š2,5ä¼‘æ¯
                [2,5,0,1], // ç¬¬9åœºï¼š3,4ä¼‘æ¯
                [3,4,2,5], // ç¬¬10åœºï¼š0,1ä¼‘æ¯
                [0,1,4,5], // ç¬¬11åœºï¼š2,3ä¼‘æ¯
                [2,3,0,5], // ç¬¬12åœºï¼š1,4ä¼‘æ¯
                [1,4,2,0], // ç¬¬13åœºï¼š3,5ä¼‘æ¯
                [3,5,1,2], // ç¬¬14åœºï¼š0,4ä¼‘æ¯
                [0,4,3,1]  // ç¬¬15åœºï¼š2,5ä¼‘æ¯
            ];
            
            // éªŒè¯è¿™ä¸ªå›ºå®šæ–¹æ¡ˆ
            console.log('ğŸ” éªŒè¯å›ºå®šæ–¹æ¡ˆ...');
            
            // æ£€æŸ¥æ¯äººå‚ä¸æ¬¡æ•°
            const playerCounts = Array(6).fill(0);
            fixedSchedule.forEach(match => {
                match.forEach(playerId => playerCounts[playerId]++);
            });
            
            console.log('ğŸ“Š å›ºå®šæ–¹æ¡ˆæ¯äººåœºæ¬¡:', playerCounts);
            if (!playerCounts.every(count => count === 10)) {
                throw new Error(`å›ºå®šæ–¹æ¡ˆåœºæ¬¡é”™è¯¯: [${playerCounts.join(',')}], åº”è¯¥æ¯äºº10åœº`);
            }
            
            // æ£€æŸ¥è¿ç»­æ¯”èµ›
            for (let playerId = 0; playerId < 6; playerId++) {
                const playerMatches = [];
                fixedSchedule.forEach((match, index) => {
                    if (match.includes(playerId)) {
                        playerMatches.push(index);
                    }
                });
                
                // æ£€æŸ¥è¿ç»­
                for (let i = 1; i < playerMatches.length; i++) {
                    if (playerMatches[i] === playerMatches[i-1] + 1) {
                        throw new Error(`å›ºå®šæ–¹æ¡ˆé”™è¯¯ï¼šç©å®¶${playerId+1}åœ¨ç¬¬${playerMatches[i-1]+1}å’Œ${playerMatches[i]+1}åœºè¿ç»­æ¯”èµ›`);
                    }
                }
                
                console.log(`   ç©å®¶${playerId+1}: ç¬¬${playerMatches.map(m => m+1).join(',')}åœº âœ“`);
            }
            
            // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
            const matches = fixedSchedule.map((match, index) => {
                // éšæœºåˆ†ç»„
                const shuffled = [...match].sort(() => Math.random() - 0.5);
                return {
                    team1: [players[shuffled[0]], players[shuffled[1]]],
                    team2: [players[shuffled[2]], players[shuffled[3]]],
                    score1: 0,
                    score2: 0,
                    matchIndex: index
                };
            });
            
            console.log('âœ… å›ºå®šæ–¹æ¡ˆéªŒè¯é€šè¿‡ï¼šæ¯äºº10åœºï¼Œç»å¯¹æ— è¿ç»­æ¯”èµ›');
            return matches;
        }

        // ä¸¥æ ¼çš„æ•°å­¦éªŒè¯ç®—æ³• - ç»å¯¹ä¿è¯åœºæ¬¡å’Œè¿ç»­æ€§
        function generateOptimalSchedule(playerCount, players) {
            console.log('ğŸ”¥ ä½¿ç”¨ä¸¥æ ¼æ•°å­¦éªŒè¯ç®—æ³•');
            
            const targetMatches = 15;
            const targetPerPlayer = playerCount === 6 ? 10 : 12;
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„4äººç»„åˆï¼ˆ6äººä¸­é€‰4äººï¼‰
            const allCombinations = [];
            
            if (playerCount === 6) {
                // 6äººæ¨¡å¼ï¼šä»6äººä¸­é€‰4äººï¼Œæœ‰C(6,4)=15ç§é€‰æ³•ï¼Œæ¯ç§æœ‰3ç§åˆ†ç»„æ–¹å¼
                for (let i = 0; i < 6; i++) {
                    for (let j = i + 1; j < 6; j++) {
                        for (let k = j + 1; k < 6; k++) {
                            for (let l = k + 1; l < 6; l++) {
                                // 4äººç»„åˆ [i,j,k,l]ï¼Œå‰©ä¸‹2äººä¼‘æ¯
                                const playingPlayers = [i, j, k, l];
                                
                                // ç”Ÿæˆè¿™4äººçš„æ‰€æœ‰åˆ†ç»„æ–¹å¼
                                const groupings = [
                                    { team1: [i, j], team2: [k, l], players: playingPlayers },
                                    { team1: [i, k], team2: [j, l], players: playingPlayers },
                                    { team1: [i, l], team2: [j, k], players: playingPlayers }
                                ];
                                
                                allCombinations.push(...groupings);
                            }
                        }
                    }
                }
            } else {
                // å…¶ä»–äººæ•°çš„å¤„ç†ï¼ˆä¿æŒåŸé€»è¾‘ï¼‰
                for (let i = 0; i < playerCount; i++) {
                    for (let j = i + 1; j < playerCount; j++) {
                        for (let k = 0; k < playerCount; k++) {
                            if (k !== i && k !== j) {
                                for (let l = k + 1; l < playerCount; l++) {
                                    if (l !== i && l !== j) {
                                        allCombinations.push({
                                            team1: [i, j],
                                            team2: [k, l],
                                            players: [i, j, k, l]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            console.log(`æ€»å…±${allCombinations.length}ç§4äººç»„åˆå¯é€‰`);
            
            // å¤šæ¬¡å°è¯•ç”Ÿæˆå®Œç¾å®‰æ’
            for (let attempt = 0; attempt < 1000; attempt++) {
                const matches = [];
                const playerLastMatch = Array(playerCount).fill(-999);
                const playerMatchCount = Array(playerCount).fill(0);
                const usedCombinations = new Set();
                
                // åˆå§‹åŒ–å…¨å±€æ­é…ç®¡ç†å™¨ï¼ˆ6äºº/é€šç”¨æ¨¡å¼ï¼‰
                globalPartnershipManager = new PartnershipManager(playerCount);
                
                let success = true;
                
                for (let matchIndex = 0; matchIndex < targetMatches; matchIndex++) {
                    const validCombos = [];
                    
                    // ä¸¥æ ¼ç­›é€‰å¯ç”¨ç»„åˆ
                    for (const combo of allCombinations) {
                        const comboKey = combo.players.slice().sort().join(',');
                        if (usedCombinations.has(comboKey)) continue;
                        
                        // ä¸¥æ ¼æ£€æŸ¥åœºæ¬¡é™åˆ¶
                        let exceedsLimit = false;
                        for (const playerId of combo.players) {
                            if (playerMatchCount[playerId] >= targetPerPlayer) {
                                exceedsLimit = true;
                                break;
                            }
                        }
                        if (exceedsLimit) continue;
                        
                        // ä¸¥æ ¼æ£€æŸ¥è¿ç»­æ¯”èµ› - ç»å¯¹ä¸å…è®¸
                        let hasConsecutive = false;
                        for (const playerId of combo.players) {
                            if (playerLastMatch[playerId] === matchIndex - 1) {
                                hasConsecutive = true;
                                break;
                            }
                        }
                        if (hasConsecutive) continue;
                        
                        validCombos.push(combo);
                    }
                    
                    if (validCombos.length === 0) {
                        success = false;
                        break;
                    }
                    
                    // é€‰æ‹©æœ€ä¼˜ç»„åˆ
                    let bestCombo = null;
                    let bestScore = -Infinity;
                    
                    for (const combo of validCombos) {
                        let score = 0;
                        
                        // ä¼˜å…ˆå®‰æ’æ¯”èµ›æ¬¡æ•°å°‘çš„äºº
                        for (const playerId of combo.players) {
                            const remaining = targetPerPlayer - playerMatchCount[playerId];
                            score += remaining * 1000; // é«˜æƒé‡
                        }
                        
                        // ä¼˜å…ˆå®‰æ’ä¼‘æ¯ä¹…çš„äºº
                        for (const playerId of combo.players) {
                            const restTime = matchIndex - playerLastMatch[playerId];
                            score += Math.min(restTime * 100, 500);
                        }
                        
                        // æ–°å¢ï¼šä½¿ç”¨å…¨å±€æ­é…ç®¡ç†å™¨ï¼ˆ6äºº/é€šç”¨æ¨¡å¼ï¼‰
                        const team1Players = combo.team1;
                        const team2Players = combo.team2;
                        
                        // ç¡¬é™åˆ¶ï¼šæ£€æŸ¥æ­é…æ˜¯å¦è¶…æ ‡
                        if (!globalPartnershipManager.canFormTeam(team1Players, team2Players)) {
                            continue; // ç›´æ¥è·³è¿‡è¿™ä¸ªç»„åˆï¼Œä¸å…è®¸è¶…æ ‡
                        }
                        
                        // æ­é…ä¼˜å…ˆçº§è¯„åˆ†
                        let partnershipScore = 0;
                        partnershipScore += globalPartnershipManager.getPartnershipScore(team1Players[0], team1Players[1]);
                        partnershipScore += globalPartnershipManager.getPartnershipScore(team2Players[0], team2Players[1]);
                        
                        // é¢å¤–å¥–åŠ±åŒ…å«æœ€å°‘ä½¿ç”¨é…å¯¹çš„ç»„åˆ
                        if (globalPartnershipManager.containsLeastUsedPair(team1Players, team2Players)) {
                            partnershipScore += 15000; // å¤§å¹…å¥–åŠ±æœ€å°‘ä½¿ç”¨çš„é…å¯¹
                        }
                        
                        score += partnershipScore;
                        
                        // å°çš„éšæœºå› å­ï¼ˆå‡å°‘éšæœºæ€§ï¼Œè®©ç®—æ³•æ›´å€¾å‘äºå‡è¡¡æ­é…ï¼‰
                        score += Math.random() * 5;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestCombo = combo;
                        }
                    }
                    
                    if (bestCombo) {
                        matches.push({
                            team1: [players[bestCombo.team1[0]], players[bestCombo.team1[1]]],
                            team2: [players[bestCombo.team2[0]], players[bestCombo.team2[1]]],
                            score1: 0,
                            score2: 0,
                            matchIndex: matchIndex
                        });
                        
                        // æ›´æ–°å…¨å±€æ­é…ç®¡ç†å™¨
                        globalPartnershipManager.addTeams(bestCombo.team1, bestCombo.team2);
                        
                        // æ›´æ–°çŠ¶æ€
                        for (const playerId of bestCombo.players) {
                            playerLastMatch[playerId] = matchIndex;
                            playerMatchCount[playerId]++;
                        }
                        
                        usedCombinations.add(bestCombo.players.slice().sort().join(','));
                    } else {
                        success = false;
                        break;
                    }
                }
                
                // å¦‚æœç”ŸæˆæˆåŠŸï¼Œè¿›è¡Œæœ€ä¸¥æ ¼çš„éªŒè¯
                if (success && matches.length === targetMatches) {
                    // å…ˆåšå¿«é€Ÿåœºæ¬¡æ£€æŸ¥
                    const quickCheck = playerMatchCount.every(count => count === targetPerPlayer);
                    if (!quickCheck) {
                        console.warn(`âŒ å¿«é€Ÿæ£€æŸ¥å¤±è´¥ï¼šåœºæ¬¡åˆ†é…ä¸å‡ [${playerMatchCount.join(',')}]ï¼Œç›®æ ‡æ¯äºº${targetPerPlayer}åœº`);
                        continue;
                    }
                    
                    const isValid = validateMatchesStrictly(matches, playerCount, players, targetPerPlayer);
                    if (isValid) {
                        console.log(`âœ… ç”Ÿæˆå®Œç¾å®‰æ’ï¼å°è¯•${attempt + 1}æ¬¡`);
                        console.log(`ğŸ“Š æœ€ç»ˆåœºæ¬¡åˆ†é…ï¼š[${playerMatchCount.join(',')}]`);
                        return matches;
                    }
                }
                
                // æ¯50æ¬¡å°è¯•è¾“å‡ºè°ƒè¯•ä¿¡æ¯
                if ((attempt + 1) % 50 === 0) {
                    console.log(`ğŸ”„ ${playerCount}äººå®‰æ’å°è¯•è¿›åº¦ï¼š${attempt + 1}/1000`);
                    if (matches.length === targetMatches) {
                        console.log(`   å½“å‰åœºæ¬¡åˆ†é…ï¼š[${playerMatchCount.join(',')}]ï¼Œç›®æ ‡æ¯äºº${targetPerPlayer}åœº`);
                    }
                }
            }
            
            console.error('âŒ 1000æ¬¡å°è¯•éƒ½å¤±è´¥äº†ï¼ä½¿ç”¨æ•°å­¦æ„é€ æ³•');
            return generateMathematicalSolution(playerCount, players, targetPerPlayer);
        }
        
        // æ•°å­¦æ„é€ æ³• - ç»å¯¹æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆ
        function generateMathematicalSolution(playerCount, players, targetPerPlayer) {
            console.log('ğŸ§® ä½¿ç”¨æ•°å­¦æ„é€ æ³•ç”Ÿæˆç»å¯¹æ­£ç¡®çš„å®‰æ’');
            
            if (playerCount === 6) {
                // 6äººæ•°å­¦æ„é€ ï¼šæ¯äººæ°å¥½10åœºï¼Œç»å¯¹æ— è¿ç»­
                return generate6PlayerMathematicalSolution(players);
            } else if (playerCount === 5) {
                // 5äººæ•°å­¦æ„é€ ï¼šæ¯äººæ°å¥½12åœºï¼Œç»å¯¹æ— è¿ç»­ï¼Œå¸¦é‡è¯•æœºåˆ¶
                const maxRetries = 50; // æœ€å¤šé‡è¯•50æ¬¡
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        console.log(`ğŸ¯ 5äººæ•°å­¦æ„é€ å°è¯• ${attempt}/${maxRetries}`);
                        return generate5PlayerMathematicalSolution(players);
                    } catch (error) {
                        if (error.message.includes('æ­é…ä¸å‡è¡¡') && attempt < maxRetries) {
                            console.warn(`âš ï¸ ç¬¬${attempt}æ¬¡å°è¯•æ­é…ä¸å‡è¡¡ï¼Œé‡æ–°ç”Ÿæˆ...`);
                            continue; // é‡è¯•
                        } else {
                            console.error(`âŒ 5äººæ•°å­¦æ„é€ æœ€ç»ˆå¤±è´¥ (${attempt}æ¬¡å°è¯•):`, error.message);
                            throw error;
                        }
                    }
                }
                throw new Error(`5äººæ•°å­¦æ„é€ å¤±è´¥ï¼š${maxRetries}æ¬¡å°è¯•éƒ½æ— æ³•ç”Ÿæˆå‡è¡¡æ­é…`);
            } else {
                throw new Error(`ä¸æ”¯æŒ${playerCount}äººçš„æ•°å­¦æ„é€ `);
            }
        }
        
        // 6äººæ•°å­¦æ„é€ è§£å†³æ–¹æ¡ˆ - ä½¿ç”¨ç®—æ³•ä¿è¯æ­£ç¡®æ€§
        function generate6PlayerMathematicalSolution(players) {
            console.log('ğŸ¯ 6äººæ•°å­¦æ„é€ ï¼šç¡®ä¿æ¯äººæ°å¥½10åœºï¼Œç»å¯¹æ— è¿ç»­');
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„4äººç»„åˆ C(6,4) = 15
            const allCombinations = [];
            for (let i = 0; i < 6; i++) {
                for (let j = i + 1; j < 6; j++) {
                    for (let k = j + 1; k < 6; k++) {
                        for (let l = k + 1; l < 6; l++) {
                            allCombinations.push([i, j, k, l]);
                        }
                    }
                }
            }
            
            console.log(`6äººå…±æœ‰${allCombinations.length}ç§4äººç»„åˆ`);
            
            // éªŒè¯ç»„åˆæ•°å­¦æ­£ç¡®æ€§
            const expectedCombinations = 15; // C(6,4) = 15
            if (allCombinations.length !== expectedCombinations) {
                throw new Error(`ç»„åˆæ•°é”™è¯¯ï¼æœŸæœ›${expectedCombinations}ä¸ªï¼Œå®é™…${allCombinations.length}ä¸ª`);
            }
            
            // éªŒè¯æ¯äººç†è®ºå‡ºç°æ¬¡æ•°
            const playerAppearances = Array(6).fill(0);
            allCombinations.forEach(combo => {
                combo.forEach(playerId => playerAppearances[playerId]++);
            });
            console.log('ğŸ”¢ ç†è®ºæ¯äººå‡ºç°æ¬¡æ•°:', playerAppearances);
            
            const expectedPerPlayer = 10; // (15 * 4) / 6 = 10
            if (!playerAppearances.every(count => count === expectedPerPlayer)) {
                throw new Error(`ç†è®ºåˆ†é…é”™è¯¯ï¼æœŸæœ›æ¯äºº${expectedPerPlayer}æ¬¡ï¼Œå®é™…[${playerAppearances.join(',')}]`);
            }
            
            // ä½¿ç”¨æ™ºèƒ½å›æº¯ç®—æ³•ï¼Œå¹³è¡¡æ¯”èµ›å’Œä¼‘æ¯åˆ†å¸ƒ
            function findValidSchedule() {
                const schedule = [];
                const used = new Set();
                const lastMatch = Array(6).fill(-999);
                const matchCount = Array(6).fill(0);
                
                // åˆå§‹åŒ–å…¨å±€æ­é…ç®¡ç†å™¨ï¼ˆæ™ºèƒ½å›æº¯ç®—æ³•ï¼‰
                globalPartnershipManager = new PartnershipManager(6);
                
                // è®¡ç®—ç»„åˆçš„å…¬å¹³æ€§åˆ†æ•°
                function calculateFairnessScore(combo, matchIndex) {
                    let score = 0;
                    
                    // 1. ä¼˜å…ˆé€‰æ‹©æ¯”èµ›æ¬¡æ•°å°‘çš„äºº
                    for (const playerId of combo) {
                        const remaining = 10 - matchCount[playerId];
                        score += remaining * 1000; // é«˜æƒé‡
                    }
                    
                    // 2. å¹³è¡¡ä¼‘æ¯æ—¶é—´ - é¿å…ä¼‘æ¯è¿‡ä¹…æˆ–è¿‡çŸ­
                    let totalRestTime = 0;
                    let minRestTime = Infinity;
                    let maxRestTime = -Infinity;
                    
                    for (const playerId of combo) {
                        const restTime = matchIndex - lastMatch[playerId];
                        totalRestTime += restTime;
                        minRestTime = Math.min(minRestTime, restTime);
                        maxRestTime = Math.max(maxRestTime, restTime);
                        
                        // ç†æƒ³ä¼‘æ¯æ—¶é—´æ˜¯1-2åœº
                        if (restTime >= 2 && restTime <= 3) {
                            score += 500; // å¥–åŠ±ç†æƒ³ä¼‘æ¯æ—¶é—´
                        } else if (restTime === 1) {
                            score += 100; // å¯ä»¥æ¥å—
                        } else if (restTime >= 4) {
                            score -= (restTime - 3) * 200; // æƒ©ç½šä¼‘æ¯è¿‡ä¹…
                        }
                    }
                    
                    // 3. å¥–åŠ±ä¼‘æ¯æ—¶é—´å‡åŒ€çš„ç»„åˆ
                    const restTimeVariance = maxRestTime - minRestTime;
                    if (restTimeVariance <= 1) {
                        score += 300; // å¥–åŠ±ä¼‘æ¯æ—¶é—´ç›¸è¿‘
                    } else {
                        score -= restTimeVariance * 50; // æƒ©ç½šä¼‘æ¯æ—¶é—´å·®è·å¤§
                    }
                    
                    // 4. é¿å…è®©ä¼‘æ¯å¤ªä¹…çš„äººç»§ç»­ä¼‘æ¯
                    for (let playerId = 0; playerId < 6; playerId++) {
                        if (!combo.includes(playerId)) { // è¿™ä¸ªäººè¦ä¼‘æ¯
                            const currentRestTime = matchIndex - lastMatch[playerId];
                            if (currentRestTime >= 3) {
                                score -= 400; // æƒ©ç½šè®©å·²ç»ä¼‘æ¯ä¹…çš„äººç»§ç»­ä¼‘æ¯
                            }
                        }
                    }
                    
                    // 5. æ–°å¢ï¼šä½¿ç”¨å…¨å±€æ­é…ç®¡ç†å™¨æ£€æŸ¥ï¼ˆ6äººæ¨¡å¼æ™ºèƒ½å›æº¯ï¼‰
                    // ç”Ÿæˆè¿™ä¸ªç»„åˆçš„æ‰€æœ‰å¯èƒ½é˜Ÿä¼åˆ†ç»„
                    const possibleTeams = [
                        [[combo[0], combo[1]], [combo[2], combo[3]]],
                        [[combo[0], combo[2]], [combo[1], combo[3]]],
                        [[combo[0], combo[3]], [combo[1], combo[2]]]
                    ];
                    
                    // æ‰¾åˆ°æœ€ä½³çš„åˆ†ç»„æ–¹å¼
                    let bestPartnershipScore = -100000;
                    
                    for (const teamConfig of possibleTeams) {
                        // æ£€æŸ¥è¿™ç§åˆ†ç»„æ˜¯å¦è¶…æ ‡
                        if (!globalPartnershipManager.canFormTeam(teamConfig[0], teamConfig[1])) {
                            continue; // è¿™ç§åˆ†ç»„ä¼šå¯¼è‡´è¶…æ ‡ï¼Œè·³è¿‡
                        }
                        
                        // è®¡ç®—è¿™ç§åˆ†ç»„çš„ä¼˜å…ˆçº§åˆ†æ•°
                        let teamingScore = 0;
                        teamingScore += globalPartnershipManager.getPartnershipScore(teamConfig[0][0], teamConfig[0][1]);
                        teamingScore += globalPartnershipManager.getPartnershipScore(teamConfig[1][0], teamConfig[1][1]);
                        
                        // é¢å¤–å¥–åŠ±åŒ…å«æœ€å°‘ä½¿ç”¨é…å¯¹çš„ç»„åˆ
                        if (globalPartnershipManager.containsLeastUsedPair(teamConfig[0], teamConfig[1])) {
                            teamingScore += 15000; // å¤§å¹…å¥–åŠ±æœ€å°‘ä½¿ç”¨çš„é…å¯¹
                        }
                        
                        bestPartnershipScore = Math.max(bestPartnershipScore, teamingScore);
                    }
                    
                    // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„åˆ†ç»„æ–¹å¼ï¼Œè¿”å›æä½åˆ†æ•°
                    if (bestPartnershipScore === -100000) {
                        return -100000; // è¿™ä¸ªç»„åˆä¼šå¯¼è‡´æ­é…è¶…æ ‡ï¼Œç›´æ¥æ‹’ç»
                    }
                    
                    score += bestPartnershipScore;
                    
                    return score;
                }
                
                function backtrack(matchIndex) {
                    if (matchIndex === 15) {
                        return true; // æˆåŠŸæ‰¾åˆ°å®Œæ•´å®‰æ’
                    }
                    
                    // è·å–æ‰€æœ‰å¯ç”¨ç»„åˆå¹¶æŒ‰å…¬å¹³æ€§æ’åº
                    const availableCombos = [];
                    for (const combo of allCombinations) {
                        const comboKey = combo.join(',');
                        if (used.has(comboKey)) continue;
                        
                        // æ£€æŸ¥è¿ç»­æ¯”èµ›çº¦æŸ - åŠ å¼ºç‰ˆ
                        let hasConsecutive = false;
                        let consecutivePlayer = -1;
                        for (const playerId of combo) {
                            if (lastMatch[playerId] === matchIndex - 1) {
                                hasConsecutive = true;
                                consecutivePlayer = playerId;
                                break;
                            }
                        }
                        if (hasConsecutive) {
                            // è°ƒè¯•ä¿¡æ¯ï¼šè®°å½•è¢«æ‹’ç»çš„è¿ç»­ç»„åˆ
                            if (matchIndex <= 5) { // åªåœ¨å‰å‡ åœºè®°å½•ï¼Œé¿å…æ—¥å¿—è¿‡å¤š
                                console.log(`   æ‹’ç»ç»„åˆ[${combo.join(',')}]: ç©å®¶${consecutivePlayer+1}ä¼šè¿ç»­æ¯”èµ›`);
                            }
                            continue;
                        }
                        
                        // è®¡ç®—å…¬å¹³æ€§åˆ†æ•°
                        const fairnessScore = calculateFairnessScore(combo, matchIndex);
                        availableCombos.push({ combo, score: fairnessScore });
                    }
                    
                    // æŒ‰å…¬å¹³æ€§åˆ†æ•°é™åºæ’åºï¼Œä¼˜å…ˆå°è¯•æ›´å…¬å¹³çš„ç»„åˆ
                    availableCombos.sort((a, b) => b.score - a.score);
                    
                    // å°è¯•æœ€å…¬å¹³çš„ç»„åˆ
                    for (const { combo, score } of availableCombos) {
                        // è°ƒè¯•ä¿¡æ¯ï¼šè®°å½•é€‰æ‹©çš„ç»„åˆ
                        if (matchIndex <= 5) { // åªåœ¨å‰å‡ åœºè®°å½•
                            console.log(`   å°è¯•ç¬¬${matchIndex + 1}åœº: [${combo.join(',')}] (ç©å®¶${combo.map(id => id+1).join(',')}) åˆ†æ•°:${score.toFixed(1)}`);
                        }
                        
                        // å°è¯•è¿™ä¸ªç»„åˆ
                        schedule[matchIndex] = combo;
                        used.add(combo.join(','));
                        
                        // æ›´æ–°çŠ¶æ€
                        const oldLastMatch = [...lastMatch];
                        const oldMatchCount = [...matchCount];
                        for (const playerId of combo) {
                            lastMatch[playerId] = matchIndex;
                            matchCount[playerId]++;
                        }
                        
                        // é€’å½’å°è¯•ä¸‹ä¸€åœº
                        if (backtrack(matchIndex + 1)) {
                            return true;
                        }
                        
                        // å›æº¯
                        if (matchIndex <= 5) { // åªåœ¨å‰å‡ åœºè®°å½•
                            console.log(`   å›æº¯ç¬¬${matchIndex + 1}åœº: [${combo.join(',')}] å¤±è´¥`);
                        }
                        schedule[matchIndex] = null;
                        used.delete(combo.join(','));
                        for (let i = 0; i < 6; i++) {
                            lastMatch[i] = oldLastMatch[i];
                            matchCount[i] = oldMatchCount[i];
                        }
                    }
                    
                    return false; // æ— æ³•æ‰¾åˆ°æœ‰æ•ˆå®‰æ’
                }
                
                if (backtrack(0)) {
                    return schedule;
                } else {
                    throw new Error('æ™ºèƒ½å›æº¯ç®—æ³•å¤±è´¥ï¼šæ— æ³•æ‰¾åˆ°å…¬å¹³çš„6äººå®‰æ’');
                }
            }
            
            console.log('ğŸ”„ ä½¿ç”¨å›æº¯ç®—æ³•ç”Ÿæˆ6äººå®‰æ’...');
            const selectedMatches = findValidSchedule();
            console.log('âœ… å›æº¯ç®—æ³•æˆåŠŸç”Ÿæˆå®Œæ•´å®‰æ’ï¼');
            
            // ç«‹å³éªŒè¯å›æº¯ç»“æœçš„æ­£ç¡®æ€§
            const quickCheck = Array(6).fill(0);
            selectedMatches.forEach(match => {
                match.forEach(playerId => quickCheck[playerId]++);
            });
            console.log('ğŸ” å›æº¯ç®—æ³•ç»“æœå¿«é€Ÿæ£€æŸ¥:', quickCheck);
            
            // è¯¦ç»†æŠ¥å‘Šæ¯äººåœºæ¬¡
            for (let i = 0; i < 6; i++) {
                console.log(`   ç©å®¶${i+1}: ${quickCheck[i]}åœº`);
                if (quickCheck[i] !== 10) {
                    console.error(`âŒ ç©å®¶${i+1}åœºæ¬¡é”™è¯¯ï¼š${quickCheck[i]}åœºï¼Œåº”è¯¥10åœº`);
                }
            }
            
            if (!quickCheck.every(count => count === 10)) {
                console.error('âŒ å›æº¯ç®—æ³•ç»“æœé”™è¯¯ï¼æ¯äººåœºæ¬¡:', quickCheck);
                console.error('æ€»åœºæ¬¡:', quickCheck.reduce((a, b) => a + b, 0), 'åº”è¯¥æ˜¯60');
                throw new Error(`å›æº¯ç®—æ³•äº§ç”Ÿäº†é”™è¯¯çš„ç»“æœ: [${quickCheck.join(',')}]`);
            }
            
            // ä¸¥æ ¼æ£€æŸ¥è¿ç»­æ¯”èµ› - ç»å¯¹ä¸èƒ½æœ‰ä»»ä½•è¿ç»­
            console.log('ğŸ” ä¸¥æ ¼æ£€æŸ¥è¿ç»­æ¯”èµ›...');
            for (let playerId = 0; playerId < 6; playerId++) {
                const playerMatches = [];
                selectedMatches.forEach((match, index) => {
                    if (match.includes(playerId)) {
                        playerMatches.push(index);
                    }
                });
                
                // æ£€æŸ¥æ˜¯å¦æœ‰è¿ç»­åœºæ¬¡
                for (let i = 1; i < playerMatches.length; i++) {
                    if (playerMatches[i] === playerMatches[i-1] + 1) {
                        console.error(`âŒ ç©å®¶${playerId+1}è¿ç»­æ¯”èµ›ï¼šç¬¬${playerMatches[i-1]+1}å’Œ${playerMatches[i]+1}åœº`);
                        console.error('è¯¥ç©å®¶æ‰€æœ‰æ¯”èµ›åœºæ¬¡:', playerMatches.map(m => m+1));
                        throw new Error(`å›æº¯ç®—æ³•å¤±è´¥ï¼šç©å®¶${playerId+1}æœ‰è¿ç»­æ¯”èµ›`);
                    }
                }
                
                console.log(`   ç©å®¶${playerId+1}: ç¬¬${playerMatches.map(m => m+1).join(',')}åœº âœ“`);
            }
            
            // éªŒè¯æ¯äººåœºæ¬¡æ•° - è¯¦ç»†è°ƒè¯•
            const playerCounts = Array(6).fill(0);
            const playerMatchDetails = Array(6).fill(null).map(() => []);
            
            selectedMatches.forEach((match, index) => {
                match.forEach(playerId => {
                    playerCounts[playerId]++;
                    playerMatchDetails[playerId].push(index + 1);
                });
            });
            
            console.log('ğŸ“Š 6äººæ•°å­¦æ„é€ éªŒè¯ - æ¯äººåœºæ¬¡:', playerCounts);
            console.log('ğŸ“‹ è¯¦ç»†æ¯”èµ›å®‰æ’:');
            for (let i = 0; i < 6; i++) {
                console.log(`   ç©å®¶${i+1}: ${playerCounts[i]}åœº - ç¬¬${playerMatchDetails[i].join(',')}åœº`);
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰åœºæ¬¡åˆ†é…é”™è¯¯
            const wrongCounts = [];
            for (let i = 0; i < 6; i++) {
                if (playerCounts[i] !== 10) {
                    wrongCounts.push(`ç©å®¶${i+1}:${playerCounts[i]}åœº`);
                }
            }
            
            if (wrongCounts.length > 0) {
                console.error('âŒ åœºæ¬¡åˆ†é…é”™è¯¯:', wrongCounts.join(', '));
                console.error('ğŸ” è°ƒè¯•ä¿¡æ¯:');
                console.error(`   é€‰æ‹©äº†${selectedMatches.length}åœºæ¯”èµ›`);
                console.error(`   ä½¿ç”¨äº†${usedCombinations.size}ä¸ªç»„åˆ`);
                console.error(`   æ€»å…±æœ‰${allCombinations.length}ä¸ªå¯ç”¨ç»„åˆ`);
                
                // æ£€æŸ¥å“ªäº›ç»„åˆæ²¡æœ‰è¢«ä½¿ç”¨
                const unusedCombos = allCombinations.filter(combo => !usedCombinations.has(combo.join(',')));
                if (unusedCombos.length > 0) {
                    console.error(`   æœªä½¿ç”¨çš„ç»„åˆ(${unusedCombos.length}ä¸ª):`, unusedCombos);
                }
                
                throw new Error(`6äººåœºæ¬¡åˆ†é…é”™è¯¯: [${playerCounts.join(',')}], åº”è¯¥æ¯äºº10åœº`);
            }
            
            // æœ€ç»ˆç¡®è®¤æ‰€æœ‰ç»„åˆéƒ½è¢«ä½¿ç”¨ï¼ˆå›æº¯ç®—æ³•ä¿è¯äº†è¿™ä¸€ç‚¹ï¼‰
            console.log('âœ… å›æº¯ç®—æ³•ç¡®ä¿æ‰€æœ‰15ä¸ªç»„åˆéƒ½è¢«ä½¿ç”¨');
            
            // è½¬æ¢ä¸ºæ¯”èµ›æ ¼å¼
            const matches = selectedMatches.map((match, index) => {
                // éšæœºåˆ†ç»„
                const shuffled = [...match].sort(() => Math.random() - 0.5);
                return {
                    team1: [players[shuffled[0]], players[shuffled[1]]],
                    team2: [players[shuffled[2]], players[shuffled[3]]],
                    score1: 0,
                    score2: 0,
                    matchIndex: index
                };
            });
            
            // æœ€ç»ˆéªŒè¯ - åŒ…æ‹¬ä¼‘æ¯æ—¶é—´åˆ†å¸ƒæ£€æŸ¥
            const isValid = validateMatchesStrictly(matches, 6, players, 10);
            if (!isValid) {
                throw new Error('6äººæ•°å­¦æ„é€ æœ€ç»ˆéªŒè¯å¤±è´¥');
            }
            
            // éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ
            validateRestDistribution(matches, players);
            
            console.log('âœ… 6äººæ•°å­¦æ„é€ å®Œæˆï¼šæ¯äºº10åœºï¼Œæ— è¿ç»­æ¯”èµ›ï¼Œä¼‘æ¯æ—¶é—´å…¬å¹³');
            return matches;
        }
        
        // 5äººæ•°å­¦æ„é€ è§£å†³æ–¹æ¡ˆ - ä½¿ç”¨ç®—æ³•ä¿è¯æ­£ç¡®æ€§
        function generate5PlayerMathematicalSolution(players) {
            console.log('ğŸ¯ 5äººæ•°å­¦æ„é€ ï¼šç¡®ä¿æ¯äººæ°å¥½12åœºï¼Œç»å¯¹æ— è¿ç»­');
            
            // 5äººæ—¶ï¼Œæ¯åœº4äººå‚èµ›1äººä¼‘æ¯ï¼Œæ€»å…±15åœº
            // æ¯äººå‚èµ›12åœºï¼Œä¼‘æ¯3åœº
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„4äººç»„åˆ C(5,4) = 5ï¼Œä½†æˆ‘ä»¬éœ€è¦15åœº
            // æ‰€ä»¥æ¯ä¸ª4äººç»„åˆè¦ç”¨3æ¬¡ï¼Œå¯¹åº”ä¸åŒçš„åˆ†ç»„æ–¹å¼
            const allCombinations = [];
            
            // 5äººä¸­é€‰4äººçš„æ‰€æœ‰ç»„åˆï¼Œç”Ÿæˆæ­£ç¡®çš„team1/team2åˆ†ç»„
            for (let restPlayer = 0; restPlayer < 5; restPlayer++) {
                const playingPlayers = [];
                for (let i = 0; i < 5; i++) {
                    if (i !== restPlayer) {
                        playingPlayers.push(i);
                    }
                }
                
                // 4äººçš„3ç§åˆ†ç»„æ–¹å¼ï¼Œæ˜ç¡®å®šä¹‰team1å’Œteam2ï¼Œç¡®ä¿playersæ•°ç»„é¡ºåºä¸åˆ†ç»„ä¸€è‡´
                const [a, b, c, d] = playingPlayers;
                allCombinations.push({
                    players: [a, b, c, d], 
                    restPlayer: restPlayer,
                    team1: [a, b],
                    team2: [c, d]
                });
                allCombinations.push({
                    players: [a, c, b, d], 
                    restPlayer: restPlayer,
                    team1: [a, c],
                    team2: [b, d]
                });
                allCombinations.push({
                    players: [a, d, b, c], 
                    restPlayer: restPlayer,
                    team1: [a, d],
                    team2: [b, c]
                });
            }
            
            console.log(`5äººå…±æœ‰${allCombinations.length}ç§4äººç»„åˆï¼ˆå«åˆ†ç»„ï¼‰`);
            
            // éªŒè¯ç»„åˆçš„æ­£ç¡®æ€§ï¼šç¡®ä¿team1å’Œteam2æ²¡æœ‰é‡å¤ç©å®¶
            allCombinations.forEach((combo, index) => {
                const team1Players = combo.team1;
                const team2Players = combo.team2;
                const allPlayers = [...team1Players, ...team2Players];
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤ç©å®¶
                const uniquePlayers = [...new Set(allPlayers)];
                if (uniquePlayers.length !== 4) {
                    console.error(`âŒ ç»„åˆ${index}æœ‰é‡å¤ç©å®¶ï¼`, combo);
                    throw new Error(`ç»„åˆ${index}ä¸­team1å’Œteam2æœ‰é‡å¤ç©å®¶`);
                }
                
                // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¼‘æ¯ç©å®¶
                if (allPlayers.includes(combo.restPlayer)) {
                    console.error(`âŒ ç»„åˆ${index}ä¸­æ¯”èµ›ç©å®¶åŒ…å«äº†ä¼‘æ¯ç©å®¶ï¼`, combo);
                    throw new Error(`ç»„åˆ${index}ä¸­æ¯”èµ›ç©å®¶åŒ…å«äº†ä¼‘æ¯ç©å®¶`);
                }
            });
            console.log('âœ… æ‰€æœ‰ç»„åˆéªŒè¯é€šè¿‡ï¼Œæ— é‡å¤ç©å®¶');
            
            // ä½¿ç”¨è´ªå¿ƒç®—æ³•é€‰æ‹©æ— è¿ç»­çš„é¡ºåº
            const selectedMatches = [];
            const usedCombinations = new Set();
            const playerLastMatch = Array(5).fill(-999);
            const playerMatchCount = Array(5).fill(0);
            
            // åˆå§‹åŒ–å…¨å±€æ­é…ç®¡ç†å™¨ï¼ˆ5äººæ¨¡å¼ï¼‰
            globalPartnershipManager = new PartnershipManager(5);
            
            for (let matchIndex = 0; matchIndex < 15; matchIndex++) {
                let bestCombo = null;
                let bestScore = -Infinity;
                
                for (const combo of allCombinations) {
                    const comboKey = combo.players.join(',') + '-' + combo.restPlayer;
                    if (usedCombinations.has(comboKey)) continue;
                    
                    // æ£€æŸ¥åœºæ¬¡é™åˆ¶
                    let exceedsLimit = false;
                    for (const playerId of combo.players) {
                        if (playerMatchCount[playerId] >= 12) {
                            exceedsLimit = true;
                            break;
                        }
                    }
                    if (exceedsLimit) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰äººè¿ç»­æ¯”èµ›
                    let hasConsecutive = false;
                    for (const playerId of combo.players) {
                        if (playerLastMatch[playerId] === matchIndex - 1) {
                            hasConsecutive = true;
                            break;
                        }
                    }
                    if (hasConsecutive) continue;
                    
                    // è®¡ç®—ä¼˜å…ˆçº§åˆ†æ•° - å¼ºåŒ–ä¼‘æ¯å…¬å¹³æ€§
                    let score = 0;
                    let minRestTime = Infinity;
                    let totalRestTime = 0;
                    
                    // æœ€é«˜ä¼˜å…ˆçº§ï¼šä¼˜å…ˆå®‰æ’æ¯”èµ›æ¬¡æ•°å°‘çš„äºº
                    for (const playerId of combo.players) {
                        const remaining = 12 - playerMatchCount[playerId];
                        score += remaining * 10000; // æé«˜æƒé‡
                    }
                    
                    // å¼ºåŒ–ä¼‘æ¯æ—¶é—´æ£€æŸ¥
                    for (const playerId of combo.players) {
                        const restTime = matchIndex - playerLastMatch[playerId];
                        minRestTime = Math.min(minRestTime, restTime);
                        totalRestTime += restTime;
                        
                        // å¼ºçƒˆæƒ©ç½šä¼‘æ¯æ—¶é—´çŸ­çš„ç»„åˆ
                        if (restTime <= 1) {
                            score -= 100000; // æé‡åº¦æƒ©ç½š
                        } else if (restTime === 2) {
                            score -= 10000;  // é‡åº¦æƒ©ç½š
                        } else {
                            score += restTime * 1000; // é«˜å¥–åŠ±ä¼‘æ¯æ—¶é—´é•¿çš„
                        }
                    }
                    
                    // é¢å¤–å¥–åŠ±æ‰€æœ‰äººéƒ½ä¼‘æ¯å……åˆ†çš„ç»„åˆ
                    if (minRestTime >= 2) {
                        score += minRestTime * 5000;
                    }
                    
                        // æ–°å¢ï¼šä½¿ç”¨å…¨å±€æ­é…ç®¡ç†å™¨ï¼ˆ5äººæ¨¡å¼ï¼‰
                        const team1Players = combo.team1;
                        const team2Players = combo.team2;
                        
                        // ç¡¬é™åˆ¶ï¼šæ£€æŸ¥æ­é…æ˜¯å¦è¶…æ ‡
                        if (!globalPartnershipManager.canFormTeam(team1Players, team2Players)) {
                            continue; // ç›´æ¥è·³è¿‡è¿™ä¸ªç»„åˆï¼Œä¸å…è®¸è¶…æ ‡
                        }
                        
                        // æ­é…ä¼˜å…ˆçº§è¯„åˆ† - 5äººæ¨¡å¼å¼ºåŒ–å‡è¡¡æ€§
                        let partnershipScore = 0;
                        const team1Score = globalPartnershipManager.getPartnershipScore(team1Players[0], team1Players[1]);
                        const team2Score = globalPartnershipManager.getPartnershipScore(team2Players[0], team2Players[1]);
                        
                        // 5äººæ¨¡å¼ä¸‹å¤§å¹…æå‡æ­é…å‡è¡¡çš„é‡è¦æ€§
                        partnershipScore += team1Score * 50000; // è¶…é«˜æƒé‡ç¡®ä¿å‡è¡¡
                        partnershipScore += team2Score * 50000;
                        
                        // é¢å¤–å¥–åŠ±åŒ…å«æœ€å°‘ä½¿ç”¨é…å¯¹çš„ç»„åˆ
                        if (globalPartnershipManager.containsLeastUsedPair(team1Players, team2Players)) {
                            partnershipScore += 100000; // è¶…é«˜å¥–åŠ±æœ€å°‘ä½¿ç”¨çš„é…å¯¹
                        }
                        
                        // å¼ºçƒˆæƒ©ç½šæ¥è¿‘ä¸Šé™çš„æ­é…ç»„åˆï¼Œè¶…çº§å¼ºåŒ–æƒé‡
                        const team1Count = globalPartnershipManager.getCount(team1Players[0], team1Players[1]);
                        const team2Count = globalPartnershipManager.getCount(team2Players[0], team2Players[1]);
                        
                        // è¶…çº§å¼ºåŠ›æƒ©ç½šï¼Œç¡®ä¿æ­é…å‡è¡¡
                        if (team1Count >= 3) partnershipScore -= 1000000; // è¶…è¶…é‡åº¦æƒ©ç½š
                        if (team2Count >= 3) partnershipScore -= 1000000;
                        if (team1Count >= 2) partnershipScore -= 200000;  // è¶…é‡åº¦æƒ©ç½š
                        if (team2Count >= 2) partnershipScore -= 200000;
                        
                        // å¥–åŠ±æ­é…æ¬¡æ•°å°‘çš„ç»„åˆ
                        if (team1Count === 0) partnershipScore += 500000; // è¶…é«˜å¥–åŠ±ä»æœªæ­é…çš„
                        if (team2Count === 0) partnershipScore += 500000;
                        if (team1Count === 1) partnershipScore += 300000; // é«˜å¥–åŠ±åªæ­é…1æ¬¡çš„
                        if (team2Count === 1) partnershipScore += 300000;
                        
                        score += partnershipScore;
                    
                    // å¹³è¡¡ä¼‘æ¯çš„äººçš„çŠ¶æ€
                    const restPlayerRestTime = matchIndex - playerLastMatch[combo.restPlayer];
                    if (restPlayerRestTime <= 1) {
                        score += 1000; // é¼“åŠ±è®©åˆšæ¯”èµ›çš„äººä¼‘æ¯
                    } else if (restPlayerRestTime >= 4) {
                        score -= 500;  // é¿å…æŸäººä¼‘æ¯è¿‡ä¹…
                    }
                    
                    score += Math.random() * 100; // å¢å¤§éšæœºå› å­ï¼Œå¢åŠ å¤šæ ·æ€§
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestCombo = combo;
                    }
                }
                
                if (!bestCombo) {
                    throw new Error(`5äººæ•°å­¦æ„é€ å¤±è´¥ï¼šç¬¬${matchIndex + 1}åœºæ— å¯ç”¨ç»„åˆ`);
                }
                
                // éªŒè¯é€‰æ‹©çš„ç»„åˆæ²¡æœ‰é‡å¤ç©å®¶
                const team1Names = [players[bestCombo.team1[0]], players[bestCombo.team1[1]]];
                const team2Names = [players[bestCombo.team2[0]], players[bestCombo.team2[1]]];
                const allMatchPlayers = [...team1Names, ...team2Names];
                const uniqueMatchPlayers = [...new Set(allMatchPlayers)];
                
                if (uniqueMatchPlayers.length !== 4) {
                    console.error(`âŒ ç¬¬${matchIndex + 1}åœºæ¯”èµ›æœ‰é‡å¤ç©å®¶ï¼`, {
                        team1: team1Names,
                        team2: team2Names,
                        bestCombo: bestCombo
                    });
                    throw new Error(`ç¬¬${matchIndex + 1}åœºæ¯”èµ›ä¸­æœ‰ç©å®¶é‡å¤`);
                }
                
                // è®°å½•é€‰æ‹©çš„ç»„åˆ
                selectedMatches.push({
                    team1: team1Names,
                    team2: team2Names,
                    score1: 0,
                    score2: 0,
                    matchIndex: matchIndex
                });
                usedCombinations.add(bestCombo.players.join(',') + '-' + bestCombo.restPlayer);
                
                // æ›´æ–°å…¨å±€æ­é…ç®¡ç†å™¨
                globalPartnershipManager.addTeams(bestCombo.team1, bestCombo.team2);
                
                // æ›´æ–°ç©å®¶çŠ¶æ€
                for (const playerId of bestCombo.players) {
                    playerLastMatch[playerId] = matchIndex;
                    playerMatchCount[playerId]++;
                }
            }
            
            // éªŒè¯æ¯äººåœºæ¬¡æ•°
            const finalPlayerCounts = Array(5).fill(0);
            selectedMatches.forEach(match => {
                // ä»matchå¯¹è±¡ä¸­æå–ç©å®¶ç´¢å¼•è¿›è¡Œè®¡æ•°
                const team1Indices = [
                    players.indexOf(match.team1[0]),
                    players.indexOf(match.team1[1])
                ];
                const team2Indices = [
                    players.indexOf(match.team2[0]),
                    players.indexOf(match.team2[1])
                ];
                
                team1Indices.forEach(idx => { if (idx >= 0) finalPlayerCounts[idx]++; });
                team2Indices.forEach(idx => { if (idx >= 0) finalPlayerCounts[idx]++; });
            });
            
            console.log('ğŸ¯ 5äººæœ€ç»ˆåœºæ¬¡åˆ†é…ï¼š', finalPlayerCounts);
            
            // éªŒè¯æ¯äººéƒ½æ˜¯12åœº
            if (!finalPlayerCounts.every(count => count === 12)) {
                console.error('âŒ 5äººåœºæ¬¡åˆ†é…ä¸å‡ï¼å®é™…ï¼š', finalPlayerCounts, 'æœŸæœ›ï¼šæ¯äºº12åœº');
                throw new Error(`5äººåœºæ¬¡åˆ†é…é”™è¯¯ï¼š[${finalPlayerCounts.join(',')}]ï¼ŒæœŸæœ›æ¯äºº12åœº`);
            }
            
            // éªŒè¯æ­é…å‡è¡¡æ€§
            console.log('ğŸ” éªŒè¯5äººåœºæ­é…å‡è¡¡æ€§...');
            const partnershipStats = {};
            selectedMatches.forEach(match => {
                // ç»Ÿè®¡team1çš„æ­é…
                const team1Indices = [
                    players.indexOf(match.team1[0]),
                    players.indexOf(match.team1[1])
                ];
                const team2Indices = [
                    players.indexOf(match.team2[0]),
                    players.indexOf(match.team2[1])
                ];
                
                // è®°å½•æ­é…ç»Ÿè®¡
                const addPartnership = (indices) => {
                    if (indices[0] >= 0 && indices[1] >= 0) {
                        const key = `${Math.min(indices[0], indices[1])}-${Math.max(indices[0], indices[1])}`;
                        partnershipStats[key] = (partnershipStats[key] || 0) + 1;
                    }
                };
                
                addPartnership(team1Indices);
                addPartnership(team2Indices);
            });
            
            // æ£€æŸ¥æ­é…å‡è¡¡æ€§
            const counts = Object.values(partnershipStats);
            const minCount = Math.min(...counts);
            const maxCount = Math.max(...counts);
            
            console.log('ğŸ“Š 5äººåœºæ­é…ç»Ÿè®¡ï¼š', partnershipStats);
            console.log(`ğŸ“ æ­é…èŒƒå›´ï¼šæœ€å°‘${minCount}æ¬¡ï¼Œæœ€å¤š${maxCount}æ¬¡`);
            
            // 5äººåœºä¸¥æ ¼æ£€æŸ¥ï¼šæ¯å¯¹è‡³å°‘2æ¬¡ï¼Œæœ€å¤š3æ¬¡
            let hasUnbalanced = false;
            Object.entries(partnershipStats).forEach(([key, count]) => {
                const [id1, id2] = key.split('-').map(Number);
                const name1 = players[id1];
                const name2 = players[id2];
                
                if (count < 2) {
                    console.error(`âŒ æ­é…ä¸è¶³: ${name1} + ${name2} = ${count}æ¬¡ (åº”è¯¥è‡³å°‘2æ¬¡)`);
                    hasUnbalanced = true;
                } else if (count > 3) {
                    console.error(`âŒ æ­é…è¿‡å¤š: ${name1} + ${name2} = ${count}æ¬¡ (åº”è¯¥æœ€å¤š3æ¬¡)`);
                    hasUnbalanced = true;
                }
            });
            
            if (hasUnbalanced || minCount < 2 || maxCount > 3) {
                console.error(`âŒ 5äººåœºæ­é…ä¸å‡è¡¡ï¼æœ€å°‘${minCount}æ¬¡ï¼Œæœ€å¤š${maxCount}æ¬¡`);
                throw new Error(`æ­é…ä¸å‡è¡¡ï¼šæœ‰æ­é…å°‘äº2æ¬¡æˆ–å¤šäº3æ¬¡ï¼Œéœ€è¦é‡æ–°ç”Ÿæˆ`);
            } else {
                console.log('âœ… 5äººåœºæ­é…å‡è¡¡ï¼Œæ¯å¯¹éƒ½åœ¨2-3æ¬¡èŒƒå›´å†…');
            }
            
            console.log('âœ… 5äººæ•°å­¦æ„é€ å®Œæˆï¼šæ¯äººæ°å¥½12åœºï¼Œç»å¯¹æ— è¿ç»­ï¼Œæ­é…ç›¸å¯¹å‡è¡¡');
            return selectedMatches;
        }
        
        // éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒçš„å…¬å¹³æ€§
        function validateRestDistribution(matches, players) {
            console.log('ğŸ” éªŒè¯ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ...');
            
            const playerMatches = {};
            players.forEach(player => {
                playerMatches[player] = [];
            });
            
            // æ”¶é›†æ¯ä¸ªäººå‚ä¸çš„æ¯”èµ›åœºæ¬¡
            matches.forEach((match, index) => {
                [...match.team1, ...match.team2].forEach(player => {
                    if (playerMatches[player]) {
                        playerMatches[player].push(index);
                    }
                });
            });
            
            // æ£€æŸ¥æ¯ä¸ªäººçš„ä¼‘æ¯æ—¶é—´åˆ†å¸ƒ
            let hasRestIssue = false;
            for (const player of players) {
                const matchList = playerMatches[player];
                const restPeriods = [];
                
                // è®¡ç®—ä¼‘æ¯é—´éš”
                for (let i = 1; i < matchList.length; i++) {
                    const restTime = matchList[i] - matchList[i-1] - 1;
                    if (restTime > 0) {
                        restPeriods.push(restTime);
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰è¿‡é•¿çš„ä¼‘æ¯æ—¶é—´
                const maxRest = Math.max(...restPeriods, 0);
                const avgRest = restPeriods.length > 0 ? restPeriods.reduce((a, b) => a + b, 0) / restPeriods.length : 0;
                
                console.log(`   ${player}: ä¼‘æ¯é—´éš” [${restPeriods.join(',')}], æœ€é•¿${maxRest}åœº, å¹³å‡${avgRest.toFixed(1)}åœº`);
                
                if (maxRest >= 4) {
                    console.warn(`   âš ï¸ ${player}æœ€é•¿ä¼‘æ¯${maxRest}åœºï¼Œå¯èƒ½ä¸å¤Ÿå…¬å¹³`);
                    hasRestIssue = true;
                }
                
                // æ£€æŸ¥å¼€å§‹å’Œç»“æŸçš„ä¼‘æ¯æ—¶é—´
                const firstMatch = matchList[0];
                const lastMatch = matchList[matchList.length - 1];
                if (firstMatch >= 3) {
                    console.warn(`   âš ï¸ ${player}å‰${firstMatch}åœºéƒ½åœ¨ä¼‘æ¯`);
                    hasRestIssue = true;
                }
                if (lastMatch <= matches.length - 4) {
                    console.warn(`   âš ï¸ ${player}æœ€å${matches.length - 1 - lastMatch}åœºéƒ½åœ¨ä¼‘æ¯`);
                    hasRestIssue = true;
                }
            }
            
            if (hasRestIssue) {
                console.warn('âš ï¸ ä¼‘æ¯æ—¶é—´åˆ†å¸ƒå­˜åœ¨ä¸å…¬å¹³ç°è±¡ï¼Œä½†åœ¨å¯æ¥å—èŒƒå›´å†…');
            } else {
                console.log('âœ… ä¼‘æ¯æ—¶é—´åˆ†å¸ƒå…¬å¹³');
            }
        }
        
        // æœ€ä¸¥æ ¼çš„éªŒè¯å‡½æ•°
        function validateMatchesStrictly(matches, playerCount, players, targetPerPlayer) {
            const playerMatches = {};
            
            // ç»Ÿè®¡æ¯ä¸ªäººçš„æ¯”èµ›
            players.forEach(player => {
                playerMatches[player] = [];
            });
            
            matches.forEach((match, index) => {
                [...match.team1, ...match.team2].forEach(player => {
                    if (playerMatches[player]) {
                        playerMatches[player].push(index);
                    }
                });
            });
            
            // æ£€æŸ¥åœºæ¬¡
            for (const player of players) {
                const count = playerMatches[player].length;
                if (count !== targetPerPlayer) {
                    console.error(`âŒ ${player}åœºæ¬¡é”™è¯¯ï¼š${count}åœºï¼Œåº”è¯¥${targetPerPlayer}åœº`);
                    return false;
                }
            }
            
            // æ£€æŸ¥è¿ç»­æ¯”èµ› - å¢å¼ºç‰ˆ
            for (const player of players) {
                const matches = playerMatches[player];
                let consecutiveCount = 1;
                let maxConsecutive = 1;
                let consecutiveSequences = [];
                
                for (let i = 1; i < matches.length; i++) {
                    if (matches[i] === matches[i-1] + 1) {
                        consecutiveCount++;
                        maxConsecutive = Math.max(maxConsecutive, consecutiveCount);
                        
                        // è®°å½•è¿ç»­åºåˆ—
                        if (consecutiveCount === 2) {
                            consecutiveSequences.push([matches[i-1], matches[i]]);
                        } else {
                            consecutiveSequences[consecutiveSequences.length - 1].push(matches[i]);
                        }
                        
                        console.error(`âŒ ${player}è¿ç»­æ¯”èµ›ï¼šç¬¬${matches[i-1]+1}å’Œ${matches[i]+1}åœº`);
                        return false;
                    } else {
                        consecutiveCount = 1;
                    }
                }
                
                // æŠ¥å‘Šè¿ç»­æƒ…å†µ
                if (consecutiveSequences.length > 0) {
                    console.error(`âŒ ${player}æœ‰${consecutiveSequences.length}ä¸ªè¿ç»­åºåˆ—ï¼Œæœ€é•¿è¿ç»­${maxConsecutive}åœº`);
                    consecutiveSequences.forEach((seq, index) => {
                        console.error(`   åºåˆ—${index+1}: ç¬¬${seq.map(m => m+1).join(',')}åœº`);
                    });
                }
            }
            
            console.log('âœ… ä¸¥æ ¼éªŒè¯é€šè¿‡ï¼šåœºæ¬¡æ­£ç¡®ï¼Œæ— è¿ç»­æ¯”èµ›');
            return true;
        }

        // ç»å¯¹ä¿è¯å…¬å¹³çš„å¤‡ç”¨ç®—æ³• - æ‰¿è®¤æ‰‹å·¥é¢„è®¾å¤±è´¥ï¼Œç›´æ¥ä½¿ç”¨ç®—æ³•
        function generateGuaranteedFairMatches(playerCount, players) {
            console.warn('ğŸš¨ æ‰‹å·¥é¢„è®¾å®‰æ’å­˜åœ¨ç¼ºé™·ï¼Œç›´æ¥ä½¿ç”¨ç®—æ³•ç”Ÿæˆ');
            
            // ç›´æ¥ä½¿ç”¨ç®€å•ä½†å¯é çš„éšæœºç”Ÿæˆç®—æ³•
            return generateSimpleMatches(playerCount, players);
        }

        // éªŒè¯é¢„è®¾å®‰æ’çš„å…¬å¹³æ€§
        function validatePresetArrangement(matches, playerCount, description) {
            console.log(`ğŸ” éªŒè¯${description}çš„å…¬å¹³æ€§:`);
            
            // è·å–æ‰€æœ‰ç©å®¶åå•
            const allPlayers = new Set();
            matches.forEach(match => {
                match.team1.forEach(player => allPlayers.add(player));
                match.team2.forEach(player => allPlayers.add(player));
            });
            
            const playerMatches = {};
            
            // ç»Ÿè®¡æ¯ä¸ªäººå‚ä¸çš„æ¯”èµ›
            allPlayers.forEach(player => {
                playerMatches[player] = [];
                matches.forEach((match, index) => {
                    if ([...match.team1, ...match.team2].includes(player)) {
                        playerMatches[player].push(index);
                    }
                });
            });
            
            // æ£€æŸ¥åœºæ¬¡åˆ†é…å’Œè¿ç»­æ¯”èµ›
            let hasError = false;
            const expectedMatches = playerCount === 6 ? 10 : 12;
            const maxConsecutiveOverall = 1;
            
            Object.keys(playerMatches).forEach(player => {
                const playerMatchList = playerMatches[player];
                const matchCount = playerMatchList.length;
                
                console.log(`  ${player}: å‚ä¸${matchCount}åœºæ¯”èµ› (ç¬¬${playerMatchList.map(i => i+1).join(',')}åœº)`);
                
                // æ£€æŸ¥åœºæ¬¡æ•°é‡
                if (matchCount !== expectedMatches) {
                    console.error(`    âŒ åœºæ¬¡é”™è¯¯ï¼åº”è¯¥${expectedMatches}åœºï¼Œå®é™…${matchCount}åœº`);
                    hasError = true;
                }
                
                // æ£€æŸ¥è¿ç»­æ¯”èµ›
                let maxConsecutive = 1;
                let currentConsecutive = 1;
                let consecutiveSequences = [];
                let currentSequence = [playerMatchList[0]];
                
                for (let i = 1; i < playerMatchList.length; i++) {
                    if (playerMatchList[i] === playerMatchList[i-1] + 1) {
                        currentConsecutive++;
                        currentSequence.push(playerMatchList[i]);
                        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                    } else {
                        if (currentSequence.length > 1) {
                            consecutiveSequences.push([...currentSequence]);
                        }
                        currentConsecutive = 1;
                        currentSequence = [playerMatchList[i]];
                    }
                }
                
                // æ£€æŸ¥æœ€åä¸€ä¸ªåºåˆ—
                if (currentSequence.length > 1) {
                    consecutiveSequences.push(currentSequence);
                }
                
                if (maxConsecutive > 1) {
                    console.error(`    âŒ è¿ç»­æ¯”èµ›${maxConsecutive}åœº: ${consecutiveSequences.map(seq => `ç¬¬${seq[0]+1}-${seq[seq.length-1]+1}åœº`).join(', ')}`);
                    hasError = true;
                } else {
                    console.log(`    âœ… æ— è¿ç»­æ¯”èµ›ï¼Œåœºæ¬¡æ­£ç¡®`);
                }
            });
            
            // éªŒè¯æ€»ä½“ç»Ÿè®¡
            const totalMatches = Object.values(playerMatches).reduce((sum, matches) => sum + matches.length, 0);
            const expectedTotal = matches.length * 4; // æ¯åœºæ¯”èµ›4äººå‚ä¸
            
            if (totalMatches !== expectedTotal) {
                console.error(`âŒ æ€»å‚èµ›äººæ¬¡é”™è¯¯ï¼æœŸæœ›${expectedTotal}ï¼Œå®é™…${totalMatches}`);
                hasError = true;
            }
            
            if (hasError) {
                console.error(`âŒ ${description}éªŒè¯å¤±è´¥ï¼`);
                return false;
            } else {
                console.log(`âœ… ${description}éªŒè¯å®Œå…¨é€šè¿‡ï¼šåœºæ¬¡åˆ†é…æ­£ç¡®ï¼Œæ— è¿ç»­æ¯”èµ›ï¼`);
                return true;
            }
        }

        // ç”Ÿæˆç®€å•çš„æ¯”èµ›å®‰æ’ï¼ˆæœ€åçš„å¤‡ç”¨æ–¹æ¡ˆï¼‰
        function generateSimpleMatches(playerCount, players) {
            const matches = [];
            const combinations = [];
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„4äººç»„åˆ
            for (let i = 0; i < playerCount; i++) {
                for (let j = i + 1; j < playerCount; j++) {
                    for (let k = 0; k < playerCount; k++) {
                        if (k !== i && k !== j) {
                            for (let l = k + 1; l < playerCount; l++) {
                                if (l !== i && l !== j) {
                                    combinations.push({
                                        team1: [players[i], players[j]],
                                        team2: [players[k], players[l]]
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // éšæœºé€‰æ‹©15åœºæ¯”èµ›
            const shuffled = combinations.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(15, shuffled.length); i++) {
                matches.push({
                    team1: shuffled[i].team1,
                    team2: shuffled[i].team2,
                    score1: 0,
                    score2: 0,
                    matchIndex: i
                });
            }
            
            console.log(`ç”Ÿæˆç®€å•å®‰æ’ï¼š${matches.length}åœºæ¯”èµ›`);
            return matches;
        }

        // ç”Ÿæˆ5äºº15åœºæ¯”èµ›ï¼ˆæ¯äºº12åœºï¼Œé¿å…è¿ç»­æ¯”èµ›ï¼‰
        // ç”Ÿæˆ5äºº15åœºæ¯”èµ›ï¼ˆæ¯äºº12åœºï¼Œæ¯å¯¹æ­é…2-3æ¬¡ï¼‰
        function generate5PlayerMatches(players) {
            return generateSimple5PlayerSchedule(players);
        }
        
        // 5äººä¸“ç”¨ä¸¥æ ¼ç®—æ³•
        function generateStrictFivePlayerSchedule(players) {
            console.log('ğŸ¯ 5äººæ¨¡å¼ï¼š15åœºæ¯”èµ›ï¼Œæ¯äººå¿…é¡»12åœºï¼Œç»å¯¹æ— è¿ç»­');
            
            const targetMatches = 15;
            const targetPerPlayer = 12;
            const playerCount = 5;
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„4äººç»„åˆï¼ˆä»5äººä¸­é€‰4äººï¼‰
            const allCombinations = [];
            for (let i = 0; i < playerCount; i++) {
                for (let j = i + 1; j < playerCount; j++) {
                    for (let k = j + 1; k < playerCount; k++) {
                        for (let l = k + 1; l < playerCount; l++) {
                            // 4äººç»„åˆï¼Œå‰©ä¸‹1äººä¼‘æ¯
                            const playingPlayers = [i, j, k, l];
                            const restingPlayer = [0, 1, 2, 3, 4].find(p => !playingPlayers.includes(p));
                            
                            // ç”Ÿæˆè¿™4äººçš„æ‰€æœ‰åˆ†ç»„æ–¹å¼
                            const groupings = [
                                { team1: [i, j], team2: [k, l], players: playingPlayers, resting: restingPlayer },
                                { team1: [i, k], team2: [j, l], players: playingPlayers, resting: restingPlayer },
                                { team1: [i, l], team2: [j, k], players: playingPlayers, resting: restingPlayer }
                            ];
                            
                            allCombinations.push(...groupings);
                        }
                    }
                }
            }
            
            console.log(`5äººæ¨¡å¼ï¼š${allCombinations.length}ç§ç»„åˆå¯é€‰`);
            
            // å¤šæ¬¡å°è¯•ç”Ÿæˆå®Œç¾å®‰æ’
            for (let attempt = 0; attempt < 2000; attempt++) {
                const matches = [];
                const playerLastMatch = Array(playerCount).fill(-999);
                const playerMatchCount = Array(playerCount).fill(0);
                const usedCombinations = new Set();
                
                let success = true;
                
                for (let matchIndex = 0; matchIndex < targetMatches; matchIndex++) {
                    const validCombos = [];
                    
                    // ä¸¥æ ¼ç­›é€‰å¯ç”¨ç»„åˆ
                    for (const combo of allCombinations) {
                        const comboKey = combo.players.slice().sort().join(',') + '_' + combo.team1.slice().sort().join(',') + '_' + combo.team2.slice().sort().join(',');
                        if (usedCombinations.has(comboKey)) continue;
                        
                        // ä¸¥æ ¼æ£€æŸ¥åœºæ¬¡é™åˆ¶
                        let exceedsLimit = false;
                        for (const playerId of combo.players) {
                            if (playerMatchCount[playerId] >= targetPerPlayer) {
                                exceedsLimit = true;
                                break;
                            }
                        }
                        if (exceedsLimit) continue;
                        
                        // ä¸¥æ ¼æ£€æŸ¥è¿ç»­æ¯”èµ› - ç»å¯¹ä¸å…è®¸ä»»ä½•äººè¿ç»­
                        let hasConsecutive = false;
                        for (const playerId of combo.players) {
                            if (playerLastMatch[playerId] === matchIndex - 1) {
                                hasConsecutive = true;
                                break;
                            }
                        }
                        if (hasConsecutive) continue;
                        
                        // æ£€æŸ¥ä¼‘æ¯çš„äººæ˜¯å¦ä¹Ÿä¼šè¿ç»­ä¼‘æ¯å¤ªä¹…
                        const restingPlayerId = combo.resting;
                        if (playerLastMatch[restingPlayerId] < matchIndex - 3 && playerMatchCount[restingPlayerId] < targetPerPlayer) {
                            // å¦‚æœæŸäººå·²ç»ä¼‘æ¯è¶…è¿‡3åœºä¸”è¿˜éœ€è¦æ¯”èµ›ï¼Œä¼˜å…ˆè®©ä»–æ¯”èµ›
                            continue;
                        }
                        
                        validCombos.push(combo);
                    }
                    
                    if (validCombos.length === 0) {
                        success = false;
                        break;
                    }
                    
                    // é€‰æ‹©æœ€ä¼˜ç»„åˆ
                    let bestCombo = null;
                    let bestScore = -Infinity;
                    
                    for (const combo of validCombos) {
                        let score = 0;
                        
                        // æœ€é«˜ä¼˜å…ˆçº§ï¼šä¼˜å…ˆå®‰æ’æ¯”èµ›æ¬¡æ•°å°‘çš„äºº
                        for (const playerId of combo.players) {
                            const remaining = targetPerPlayer - playerMatchCount[playerId];
                            score += remaining * 10000; // æé«˜æƒé‡
                        }
                        
                        // æ¬¡ä¼˜å…ˆçº§ï¼šä¼˜å…ˆå®‰æ’ä¼‘æ¯ä¹…çš„äºº
                        for (const playerId of combo.players) {
                            const restTime = matchIndex - playerLastMatch[playerId];
                            score += Math.min(restTime * 1000, 5000);
                        }
                        
                        // æ–°å¢ï¼šé˜Ÿå‹æ­é…å¹³è¡¡æ€§æ£€æŸ¥
                        let partnershipPenalty = 0;
                        const team1Partners = combo.team1;
                        const team2Partners = combo.team2;
                        
                        // æ£€æŸ¥å·²æœ‰æ¯”èµ›ä¸­è¿™äº›æ­é…å‡ºç°çš„é¢‘ç‡
                        for (let i = 0; i < matchIndex; i++) {
                            const previousMatch = matches[i];
                            if (previousMatch) {
                                // æ£€æŸ¥é˜Ÿä¼1çš„æ­é…æ˜¯å¦é‡å¤
                                const prevTeam1Names = previousMatch.team1.map(name => 
                                    players.findIndex(p => p === name));
                                const prevTeam2Names = previousMatch.team2.map(name => 
                                    players.findIndex(p => p === name));
                                
                                // å¦‚æœå½“å‰ç»„åˆçš„é˜Ÿä¼æ­é…ä¸ä¹‹å‰çš„å®Œå…¨ç›¸åŒï¼Œç»™äºˆé‡åº¦æƒ©ç½š
                                if ((team1Partners[0] === prevTeam1Names[0] && team1Partners[1] === prevTeam1Names[1]) ||
                                    (team1Partners[0] === prevTeam1Names[1] && team1Partners[1] === prevTeam1Names[0])) {
                                    partnershipPenalty += 3000; // é‡åº¦æƒ©ç½šé‡å¤æ­é…
                                }
                                if ((team2Partners[0] === prevTeam2Names[0] && team2Partners[1] === prevTeam2Names[1]) ||
                                    (team2Partners[0] === prevTeam2Names[1] && team2Partners[1] === prevTeam2Names[0])) {
                                    partnershipPenalty += 3000; // é‡åº¦æƒ©ç½šé‡å¤æ­é…
                                }
                            }
                        }
                        
                        score -= partnershipPenalty; // å‡å»æ­é…é‡å¤çš„æƒ©ç½šåˆ†
                        
                        // å¹³è¡¡ä¼‘æ¯åˆ†é…
                        const restingPlayerId = combo.resting;
                        const restingPlayerMatches = playerMatchCount[restingPlayerId];
                        if (restingPlayerMatches < targetPerPlayer) {
                            // å¦‚æœä¼‘æ¯çš„äººè¿˜éœ€è¦æ¯”èµ›ï¼Œç¨å¾®é™ä½åˆ†æ•°
                            const remaining = targetPerPlayer - restingPlayerMatches;
                            score -= remaining * 100;
                        }
                        
                        // å°çš„éšæœºå› å­ï¼ˆå‡å°‘éšæœºæ€§ï¼Œè®©ç®—æ³•æ›´å€¾å‘äºå‡è¡¡æ­é…ï¼‰
                        score += Math.random() * 5;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestCombo = combo;
                        }
                    }
                    
                    if (bestCombo) {
                        matches.push({
                            team1: [players[bestCombo.team1[0]], players[bestCombo.team1[1]]],
                            team2: [players[bestCombo.team2[0]], players[bestCombo.team2[1]]],
                            score1: 0,
                            score2: 0,
                            matchIndex: matchIndex
                        });
                        
                        // æ›´æ–°çŠ¶æ€
                        for (const playerId of bestCombo.players) {
                            playerLastMatch[playerId] = matchIndex;
                            playerMatchCount[playerId]++;
                        }
                        
                        const comboKey = bestCombo.players.slice().sort().join(',') + '_' + bestCombo.team1.slice().sort().join(',') + '_' + bestCombo.team2.slice().sort().join(',');
                        usedCombinations.add(comboKey);
                    } else {
                        success = false;
                        break;
                    }
                }
                
                // å¦‚æœç”ŸæˆæˆåŠŸï¼Œè¿›è¡Œæœ€ä¸¥æ ¼çš„éªŒè¯
                if (success && matches.length === targetMatches) {
                    const isValid = validateMatchesStrictly(matches, playerCount, players, targetPerPlayer);
                    if (isValid) {
                        console.log(`âœ… 5äººå®Œç¾å®‰æ’ç”ŸæˆæˆåŠŸï¼å°è¯•${attempt + 1}æ¬¡`);
                        return matches;
                    }
                }
                
                // æ¯100æ¬¡å°è¯•è¾“å‡ºè¿›åº¦
                if ((attempt + 1) % 100 === 0) {
                    console.log(`ğŸ”„ 5äººå®‰æ’å°è¯•è¿›åº¦ï¼š${attempt + 1}/2000`);
                }
            }
            
            console.error('âŒ 5äººæ¨¡å¼2000æ¬¡å°è¯•éƒ½å¤±è´¥äº†ï¼');
            throw new Error('æ— æ³•ç”Ÿæˆç¬¦åˆè¦æ±‚çš„5äººæ¯”èµ›å®‰æ’');
        }
        
        // æ˜¾ç¤ºæ­é…ç»Ÿè®¡
        function displayPartnershipStats() {
            const activePlayers = getActivePlayers();
            const activePlayerCount = activePlayers.length;
            console.log('ğŸ¤ é˜Ÿå‹æ­é…ç»Ÿè®¡ï¼š');
            
            // ç»Ÿè®¡å®é™…æ­é…æƒ…å†µ
            const partnershipStats = {};
            for (let i = 0; i < activePlayerCount; i++) {
                for (let j = i + 1; j < activePlayerCount; j++) {
                    partnershipStats[`${i}-${j}`] = 0;
                }
            }
            
            matchSchedule.forEach((match, index) => {
                // ç»Ÿè®¡é˜Ÿä¼1çš„æ­é…
                const team1Ids = match.team1.map(name => 
                    activePlayers.findIndex(p => p.name === name));
                const team2Ids = match.team2.map(name => 
                    activePlayers.findIndex(p => p.name === name));
                
                if (team1Ids.length === 2 && team1Ids[0] !== -1 && team1Ids[1] !== -1) {
                    const key = `${Math.min(team1Ids[0], team1Ids[1])}-${Math.max(team1Ids[0], team1Ids[1])}`;
                    partnershipStats[key] = (partnershipStats[key] || 0) + 1;
                }
                
                if (team2Ids.length === 2 && team2Ids[0] !== -1 && team2Ids[1] !== -1) {
                    const key = `${Math.min(team2Ids[0], team2Ids[1])}-${Math.max(team2Ids[0], team2Ids[1])}`;
                    partnershipStats[key] = (partnershipStats[key] || 0) + 1;
                }
            });
            
            console.log('æ¯å¯¹æ­é…æ¬¡æ•°ï¼š');
            Object.entries(partnershipStats).forEach(([key, count]) => {
                const [id1, id2] = key.split('-').map(Number);
                const name1 = activePlayers[id1]?.name || `ç©å®¶${id1+1}`;
                const name2 = activePlayers[id2]?.name || `ç©å®¶${id2+1}`;
                console.log(`  ${name1} + ${name2}: ${count}æ¬¡`);
            });
            
            const counts = Object.values(partnershipStats);
            const minCount = Math.min(...counts);
            const maxCount = Math.max(...counts);
            const avgCount = counts.reduce((a, b) => a + b, 0) / counts.length;
            
            console.log(`æ­é…å‡è¡¡æ€§: æœ€å°‘${minCount}æ¬¡, æœ€å¤š${maxCount}æ¬¡, å¹³å‡${avgCount.toFixed(1)}æ¬¡`);
            
            // æ ¹æ®äººæ•°è°ƒæ•´å‡è¡¡æ€§æ ‡å‡†
            const currentPlayerCount = activePlayers.length;
            const targetPerPair = currentPlayerCount === 6 ? 2 : 2.4; // ç†è®ºæ­é…æ¬¡æ•°
            
            if (currentPlayerCount === 6) {
                // 6äººæ¨¡å¼ï¼šæ›´ä¸¥æ ¼çš„æ ‡å‡†ï¼Œæ¯å¯¹åº”è¯¥æ­é…2æ¬¡
                if (maxCount - minCount <= 1 && minCount >= 1 && maxCount <= 2) {
                    console.log('âœ… æ­é…éå¸¸å‡è¡¡ï¼');
                    return true;
                } else {
                    console.log('âš ï¸ 6äººæ¨¡å¼æ­é…ä¸å¤Ÿå‡è¡¡ï¼Œéœ€è¦ä¼˜åŒ–');
                    
                    // è¯¦ç»†åˆ†æé—®é¢˜
                    Object.entries(partnershipStats).forEach(([key, count]) => {
                        const [id1, id2] = key.split('-').map(Number);
                        const name1 = activePlayers[id1]?.name || `ç©å®¶${id1+1}`;
                        const name2 = activePlayers[id2]?.name || `ç©å®¶${id2+1}`;
                        
                        if (count === 0) {
                            console.warn(`âŒ æœªæ­é…: ${name1} + ${name2} = 0æ¬¡ (åº”è¯¥2æ¬¡)`);
                        } else if (count === 1) {
                            console.warn(`âš ï¸ æ­é…ä¸è¶³: ${name1} + ${name2} = 1æ¬¡ (åº”è¯¥2æ¬¡)`);
                        } else if (count > 2) {
                            console.warn(`âŒ æ­é…è¿‡å¤š: ${name1} + ${name2} = ${count}æ¬¡ (åº”è¯¥2æ¬¡)`);
                        }
                    });
                    
                    return false;
                }
            } else {
                // 5äººæ¨¡å¼ï¼šç›¸å¯¹å®½æ¾çš„æ ‡å‡†
                if (maxCount - minCount <= 2) {
                    console.log('âœ… æ­é…åŸºæœ¬å‡è¡¡ï¼');
                    return true;
                } else {
                    console.log('âš ï¸ æ­é…ä¸å¤Ÿå‡è¡¡ï¼Œéœ€è¦ä¼˜åŒ–');
                    return false;
                }
            }
        }

        // éªŒè¯15åœºæ¯”èµ›çš„å…¬å¹³æ€§
        function validateMatchFairness() {
            console.log('ğŸ¸ éªŒè¯15åœºæ¯”èµ›å…¬å¹³æ€§ï¼š');
            const activePlayers = getActivePlayers();
            const validationPlayerCount = activePlayers.length;
            
            // é¦–å…ˆéªŒè¯åŸºç¡€åœºæ¬¡åˆ†é…
            const basicMatchCounts = {};
            activePlayers.forEach(player => {
                basicMatchCounts[player.name] = 0;
            });
            
            // ç»Ÿè®¡æ¯ä¸ªç©å®¶çš„åœºæ¬¡
            matchSchedule.forEach((match, index) => {
                const allPlayingPlayers = [...match.team1, ...match.team2];
                allPlayingPlayers.forEach(playerName => {
                    if (basicMatchCounts[playerName] !== undefined) {
                        basicMatchCounts[playerName]++;
                    }
                });
            });
            
            // æ£€æŸ¥åœºæ¬¡åˆ†é…
            const expectedPerPlayer = validationPlayerCount === 6 ? 10 : 12;
            const basicCounts = Object.values(basicMatchCounts);
            const basicMin = Math.min(...basicCounts);
            const basicMax = Math.max(...basicCounts);
            
            console.log('ğŸ“Š åŸºç¡€åœºæ¬¡éªŒè¯:', basicMatchCounts);
            
            if (basicMin !== expectedPerPlayer || basicMax !== expectedPerPlayer) {
                const wrongPlayers = [];
                Object.entries(basicMatchCounts).forEach(([name, count]) => {
                    if (count !== expectedPerPlayer) {
                        wrongPlayers.push(`${name}:${count}åœº`);
                    }
                });
                throw new Error(`åŸºç¡€åœºæ¬¡åˆ†é…é”™è¯¯ï¼š${wrongPlayers.join(', ')}ï¼Œåº”è¯¥æ¯äºº${expectedPerPlayer}åœº`);
            }
            
            // æ˜¾ç¤ºæ­é…ç»Ÿè®¡
            displayPartnershipStats();
            
            // é¢å¤–æ£€æŸ¥ï¼šæ‰¾å‡ºæ­é…è¶…æ ‡çš„ç»„åˆ
            console.log('ğŸ” æ­é…è¶…æ ‡æ£€æŸ¥ï¼š');
            const partnershipStats = {};
            for (let i = 0; i < validationPlayerCount; i++) {
                for (let j = i + 1; j < validationPlayerCount; j++) {
                    partnershipStats[`${i}-${j}`] = 0;
                }
            }
            
            matchSchedule.forEach((match, index) => {
                const team1Ids = match.team1.map(name => 
                    activePlayers.findIndex(p => p.name === name));
                const team2Ids = match.team2.map(name => 
                    activePlayers.findIndex(p => p.name === name));
                
                if (team1Ids.length === 2 && team1Ids[0] !== -1 && team1Ids[1] !== -1) {
                    const key = `${Math.min(team1Ids[0], team1Ids[1])}-${Math.max(team1Ids[0], team1Ids[1])}`;
                    partnershipStats[key] = (partnershipStats[key] || 0) + 1;
                }
                
                if (team2Ids.length === 2 && team2Ids[0] !== -1 && team2Ids[1] !== -1) {
                    const key = `${Math.min(team2Ids[0], team2Ids[1])}-${Math.max(team2Ids[0], team2Ids[1])}`;
                    partnershipStats[key] = (partnershipStats[key] || 0) + 1;
                }
            });
            
            const maxAllowed = validationPlayerCount === 5 ? 3 : 2;
            let hasOverLimit = false;
            
            Object.entries(partnershipStats).forEach(([key, count]) => {
                const [id1, id2] = key.split('-').map(Number);
                const name1 = activePlayers[id1]?.name || `ç©å®¶${id1+1}`;
                const name2 = activePlayers[id2]?.name || `ç©å®¶${id2+1}`;
                
                if (count > maxAllowed) {
                    console.error(`âŒ è¶…æ ‡æ­é…: ${name1} + ${name2} = ${count}æ¬¡ (æœ€å¤šåº”è¯¥${maxAllowed}æ¬¡)`);
                    hasOverLimit = true;
                } else if (count === 0) {
                    console.warn(`âš ï¸ æœªæ­é…: ${name1} + ${name2} = 0æ¬¡`);
                }
            });
            
            if (!hasOverLimit) {
                console.log('âœ… æ‰€æœ‰æ­é…éƒ½åœ¨é™åˆ¶èŒƒå›´å†…');
            }
            
            // æ£€æŸ¥æ­é…å‡è¡¡æ€§ï¼Œå¦‚æœä¸å‡è¡¡åˆ™æŠ›å‡ºé”™è¯¯è®©ç®—æ³•é‡æ–°ç”Ÿæˆ
            displayPartnershipStats();
            
            // é¢å¤–æ£€æŸ¥æ­é…å‡è¡¡æ€§
            const counts = Object.values(partnershipStats);
            const minCount = Math.min(...counts);
            const maxCount = Math.max(...counts);
            
            // 6äººæ¨¡å¼ä¸‹ï¼Œç†è®ºä¸Šæ¯å¯¹åº”è¯¥æ­é…2æ¬¡ï¼Œå…è®¸Â±1çš„å·®è·
            // 5äººæ¨¡å¼ä¸‹ï¼Œç†è®ºä¸Šæ¯å¯¹åº”è¯¥æ­é…2.4æ¬¡ï¼Œå…è®¸è¾ƒå¤§å·®è·
            const detectedPlayerCount = Object.keys(partnershipStats).length > 10 ? 6 : 5;
            const maxAllowedGap = detectedPlayerCount === 6 ? 1 : 2; // 6äººæ¨¡å¼æ›´ä¸¥æ ¼
            
            if (maxCount - minCount > maxAllowedGap) {
                // æ‰¾å‡ºå…·ä½“ä¸å‡è¡¡çš„é…å¯¹
                const imbalancedPairs = [];
                Object.entries(partnershipStats).forEach(([key, count]) => {
                    const [id1, id2] = key.split('-').map(Number);
                    if (detectedPlayerCount === 6 && (count === 0 || count > 2)) {
                        imbalancedPairs.push(`ç©å®¶${id1+1}+ç©å®¶${id2+1}:${count}æ¬¡`);
                    } else if (detectedPlayerCount === 5 && (count < 1 || count > 3)) {
                        imbalancedPairs.push(`ç©å®¶${id1+1}+ç©å®¶${id2+1}:${count}æ¬¡`);
                    }
                });
                
                throw new Error(`æ­é…åˆ†é…ä¸å¤Ÿå‡è¡¡ï¼šæœ€å¤§å·®è·${maxCount - minCount}æ¬¡ï¼Œä¸å‡è¡¡é…å¯¹ï¼š${imbalancedPairs.join(', ')}`);
            }
            
                const playerMatchCounts = {};
            const playerPartners = {};
            const playerConsecutive = {};
            
            // åˆå§‹åŒ–ç»Ÿè®¡
            activePlayers.forEach(player => {
                    playerMatchCounts[player.name] = 0;
                playerPartners[player.name] = {};
                playerConsecutive[player.name] = [];
                });
                
            // ç»Ÿè®¡æ¯ä¸ªç©å®¶çš„å‚èµ›æ¬¡æ•°å’Œæ­æ¡£æƒ…å†µ
            matchSchedule.forEach((match, matchIndex) => {
                    const playingPlayers = [...match.team1, ...match.team2];
                
                    playingPlayers.forEach(playerName => {
                    if (playerMatchCounts[playerName] !== undefined) {
                        playerMatchCounts[playerName]++;
                        playerConsecutive[playerName].push(matchIndex);
                    }
                });
                
                // ç»Ÿè®¡æ­æ¡£å…³ç³»
                match.team1.forEach(player1 => {
                    match.team1.forEach(player2 => {
                        if (player1 !== player2) {
                            if (!playerPartners[player1][player2]) {
                                playerPartners[player1][player2] = 0;
                            }
                            playerPartners[player1][player2]++;
                        }
                    });
                });
                
                match.team2.forEach(player1 => {
                    match.team2.forEach(player2 => {
                        if (player1 !== player2) {
                            if (!playerPartners[player1][player2]) {
                                playerPartners[player1][player2] = 0;
                            }
                            playerPartners[player1][player2]++;
                        }
                    });
                });
            });
            
            console.log('ğŸ“Š å‚èµ›ç»Ÿè®¡:', playerMatchCounts);
            
            // è¯¦ç»†æ£€æŸ¥æ¯ä¸ªç©å®¶çš„åœºæ¬¡æ•°
            Object.entries(playerMatchCounts).forEach(([playerName, count]) => {
                if (count !== expectedMatches) {
                    console.error(`âŒ ${playerName}: ${count}åœºï¼Œåº”è¯¥${expectedMatches}åœº`);
                    
                    // æ‰¾å‡ºè¯¥ç©å®¶å‚ä¸çš„å…·ä½“åœºæ¬¡
                    const playerMatches = [];
                    matchSchedule.forEach((match, index) => {
                        const playingPlayers = [...match.team1, ...match.team2];
                        if (playingPlayers.includes(playerName)) {
                            playerMatches.push(index + 1);
                        }
                    });
                    console.error(`   ${playerName}å‚ä¸çš„åœºæ¬¡: ç¬¬${playerMatches.join(', ')}åœº`);
                }
            });
            console.log('ğŸ¤ æ­æ¡£ç»Ÿè®¡:', playerPartners);
            
            // æ£€æŸ¥å‚èµ›æ¬¡æ•°å…¬å¹³æ€§
                const matchCounts = Object.values(playerMatchCounts);
                const minMatches = Math.min(...matchCounts);
                const maxMatches = Math.max(...matchCounts);
                
            const expectedMatches = playerCount === 5 ? 12 : 10;
            
            if (minMatches === maxMatches && minMatches === expectedMatches) {
                console.log(`âœ… å®Œå…¨å…¬å¹³ï¼šæ¯äººéƒ½å‚åŠ ${minMatches}åœºæ¯”èµ›`);
            } else {
                console.log(`âš ï¸ å‚èµ›æ¬¡æ•°èŒƒå›´ï¼š${minMatches}-${maxMatches}åœºï¼ŒæœŸæœ›${expectedMatches}åœº`);
                
                // åˆ—å‡ºæ‰€æœ‰åœºæ¬¡ä¸æ­£ç¡®çš„ç©å®¶
                const incorrectPlayers = [];
                Object.entries(playerMatchCounts).forEach(([playerName, count]) => {
                    if (count !== expectedMatches) {
                        incorrectPlayers.push(`${playerName}:${count}åœº`);
                    }
                });
                
                console.error(`âŒ åœºæ¬¡åˆ†é…é”™è¯¯ï¼š${incorrectPlayers.join(', ')}`);
                throw new Error(`åœºæ¬¡åˆ†é…ä¸å‡åŒ€ï¼š${incorrectPlayers.join(', ')}ï¼Œéœ€è¦é‡æ–°ç”Ÿæˆ`);
            }
            
            // æ£€æŸ¥è¿ç»­æ¯”èµ›æƒ…å†µ
            Object.keys(playerConsecutive).forEach(playerName => {
                const matches = playerConsecutive[playerName];
                let maxConsecutive = 1;
                let currentConsecutive = 1;
                let consecutiveSequences = [];
                let currentSequence = [matches[0]];
                
                for (let i = 1; i < matches.length; i++) {
                    if (matches[i] === matches[i-1] + 1) {
                        currentConsecutive++;
                        currentSequence.push(matches[i]);
                        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
                    } else {
                        if (currentSequence.length > 1) {
                            consecutiveSequences.push([...currentSequence]);
                        }
                        currentConsecutive = 1;
                        currentSequence = [matches[i]];
                    }
                }
                
                // æ£€æŸ¥æœ€åä¸€ä¸ªåºåˆ—
                if (currentSequence.length > 1) {
                    consecutiveSequences.push(currentSequence);
                }
                
                console.log(`${playerName} æœ€å¤§è¿ç»­æ¯”èµ›ï¼š${maxConsecutive}åœº`);
                if (consecutiveSequences.length > 0) {
                    console.log(`  è¿ç»­æ¯”èµ›åºåˆ—:`, consecutiveSequences.map(seq => `ç¬¬${seq[0]+1}-${seq[seq.length-1]+1}åœº`).join(', '));
                }
                
                // å¦‚æœæœ‰äººè¿ç»­3åœºä»¥ä¸Šï¼Œå‘å‡ºè­¦å‘Š
                if (maxConsecutive >= 3) {
                    console.warn(`âš ï¸ ${playerName} è¿ç»­æ¯”èµ›${maxConsecutive}åœºï¼Œä¸å¤Ÿå…¬å¹³ï¼`);
                }
            });
        }
        

        // æ›´æ–°ç©å®¶æ˜¾ç¤º
        function updatePlayersDisplay() {
            const playersContainer = document.getElementById('playersNames');
            const activePlayers = getActivePlayers();
            const playerNames = activePlayers.map(player => player.name);
            playersContainer.textContent = playerNames.join(' â€¢ ');
            
            // æ›´æ–°æ ‡é¢˜ä¸­çš„äººæ•°æ˜¾ç¤º
            const headerSubtitle = document.querySelector('.header p');
            if (headerSubtitle) {
                const playerCount = activePlayers.length;
                if (playerCount === 6) {
                    headerSubtitle.textContent = '6äººè½®è½¬åˆ¶ - 15åœºæ¯”èµ›ï¼Œæ¯äºº10åœº';
                } else if (playerCount === 5) {
                    headerSubtitle.textContent = '5äººè½®è½¬åˆ¶ - 15åœºæ¯”èµ›ï¼Œæ¯äºº12åœº';
                } else {
                    headerSubtitle.textContent = `${playerCount}äººè½®è½¬åˆ¶ - è¯·é€‰æ‹©5äººæˆ–6äºº`;
                }
            }
            
            // æ›´æ–°ç©å®¶ç­›é€‰å™¨
            updatePlayerFilterButtons();
        }

        // æ›´æ–°ç©å®¶ç­›é€‰å™¨æŒ‰é’®
        function updatePlayerFilterButtons() {
            const container = document.getElementById('playerFilterButtons');
            const activePlayers = getActivePlayers();
            
            if (!container) return;
            
            container.innerHTML = '';
            
            activePlayers.forEach(player => {
                const button = document.createElement('button');
                button.className = 'player-filter-btn';
                button.textContent = player.name;
                
                // æ£€æŸ¥æ˜¯å¦è¢«é€‰ä¸­
                if (selectedPlayers.has(player.name)) {
                    button.classList.add('selected');
                }
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                button.onclick = () => {
                    togglePlayerFilter(player.name);
                };
                
                container.appendChild(button);
            });
            
            // å¦‚æœæ²¡æœ‰é€‰ä¸­ä»»ä½•ç©å®¶ï¼Œæ˜¾ç¤ºæç¤º
            if (selectedPlayers.size === 0 && activePlayers.length > 0) {
                const hint = document.createElement('div');
                hint.className = 'filter-hint';
                hint.style.cssText = `
                    color: #999;
                    font-size: 0.8rem;
                    text-align: center;
                    margin-top: 5px;
                    font-style: italic;
                `;
                hint.textContent = 'ç‚¹å‡»ç©å®¶åå­—è¿›è¡Œç­›é€‰';
                container.appendChild(hint);
            }
        }

        // æ˜¾ç¤ºç©å®¶é…ç½®å¼¹æ¡†
        function showPlayerConfigModal() {
            updatePlayerConfigDisplay();
            updateFairnessDescription();
            document.getElementById('playerConfigModal').classList.add('active');
        }

        // å…³é—­ç©å®¶é…ç½®å¼¹æ¡†
        function closePlayerConfigModal() {
            document.getElementById('playerConfigModal').classList.remove('active');
        }

        // è‡ªåŠ¨æ£€æµ‹å¹¶æ›´æ–°æ¯”èµ›æ¨¡å¼
        function updateGameMode() {
            const activeCount = getActivePlayers().length;
            const modeText = document.getElementById('currentModeText');
            
            if (activeCount === 5) {
                modeText.textContent = '5äººæ¯”èµ›æ¨¡å¼ - 15åœºæ¯”èµ›ï¼Œæ¯äºº12åœº';
            } else if (activeCount === 6) {
                modeText.textContent = '6äººæ¯”èµ›æ¨¡å¼ - 15åœºæ¯”èµ›ï¼Œæ¯äºº10åœº';
            } else if (activeCount < 5) {
                modeText.textContent = `å½“å‰${activeCount}äºº - è¯·è‡³å°‘é€‰æ‹©5äººå‚èµ›`;
            } else {
                modeText.textContent = `å½“å‰${activeCount}äºº - è¯·é€‰æ‹©5äººæˆ–6äººå‚èµ›`;
            }
            
        }

        // æ›´æ–°ç©å®¶é…ç½®æ˜¾ç¤º
        function updatePlayerConfigDisplay() {
            const container = document.getElementById('playerListConfig');
            container.innerHTML = '';
            
            playerConfig.forEach((player, index) => {
                const playerItem = document.createElement('div');
                const isSelected = selectedPlayers.has(player.name);
                playerItem.className = `player-item ${player.active ? 'active' : 'inactive'}`;
                
                // å¦‚æœç©å®¶æ¿€æ´»ï¼Œæ·»åŠ ç­›é€‰åŠŸèƒ½
                if (player.active) {
                    playerItem.classList.add('filterable');
                    if (isSelected) {
                        playerItem.classList.add('selected-filter');
                    }
                }
                
                playerItem.innerHTML = `
                    <div class="player-avatar">${player.avatar}</div>
                    <div class="player-info">
                        <input type="text" class="player-name-input" value="${player.name}" 
                               onchange="updatePlayerName(${index}, this.value)"
                               ${!player.active ? 'disabled' : ''}>
                        <div class="player-status">
                            ${player.active ? 'âœ… å‚èµ›ä¸­' : 'âŒ æœªå‚èµ›'}
                            ${isSelected ? ' ğŸ” å·²ç­›é€‰' : ''}
                        </div>
                    </div>
                    <button class="player-toggle ${player.active ? 'active' : 'inactive'}" 
                            onclick="togglePlayer(${index})"
                            ${index >= currentPlayerCount ? 'disabled' : ''}>
                        ${player.active ? 'å‚èµ›' : 'ä¼‘æ¯'}
                    </button>
                `;
                
                // ä¸ºæ¿€æ´»çš„ç©å®¶æ·»åŠ ç‚¹å‡»ç­›é€‰åŠŸèƒ½
                if (player.active) {
                    playerItem.addEventListener('click', (e) => {
                        // é¿å…ç‚¹å‡»è¾“å…¥æ¡†å’ŒæŒ‰é’®æ—¶è§¦å‘
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') {
                            return;
                        }
                        togglePlayerFilter(player.name);
                    });
                }
                
                container.appendChild(playerItem);
            });
            
            // æ›´æ–°ç­›é€‰çŠ¶æ€æ˜¾ç¤º
            updateFilterStatus();
            
            // æ›´æ–°æ¯”èµ›æ¨¡å¼æ˜¾ç¤º
            updateGameMode();
        }

        // æ›´æ–°ç©å®¶å§“å
        function updatePlayerName(index, newName) {
            if (newName.trim()) {
                playerConfig[index].name = newName.trim();
                // æ›´æ–°å¤´åƒ
                playerConfig[index].avatar = newName.trim().charAt(0).toUpperCase();
            }
        }

        // æ›´æ–°æ¯”èµ›ä¸­ç©å®¶åå­—çš„é«˜äº®çŠ¶æ€
        function updatePlayerHighlights() {
            const playerNameSpans = document.querySelectorAll('.clickable-player-name');
            
            playerNameSpans.forEach(span => {
                const playerName = span.textContent;
                const isSelected = selectedPlayers.has(playerName);
                
                if (isSelected) {
                    span.classList.add('selected');
                } else {
                    span.classList.remove('selected');
                }
            });
        }

        // ç­›é€‰åŠŸèƒ½ç›¸å…³å‡½æ•°
        
        // åˆ‡æ¢ç©å®¶ç­›é€‰çŠ¶æ€
        function togglePlayerFilter(playerName) {
            if (selectedPlayers.has(playerName)) {
                selectedPlayers.delete(playerName);
            } else {
                selectedPlayers.add(playerName);
            }
            
            // æ›´æ–°æ˜¾ç¤º
            updatePlayerConfigDisplay();
            updatePlayerFilterButtons(); // æ›´æ–°ç­›é€‰å™¨æŒ‰é’®çŠ¶æ€
            updatePlayerHighlights(); // æ›´æ–°æ¯”èµ›ä¸­ç©å®¶åå­—çš„é«˜äº®çŠ¶æ€
            applyMatchFilter();
            updateFilterStatus();
        }
        
        // æ¸…ç©ºæ‰€æœ‰ç­›é€‰
        function clearAllFilters() {
            selectedPlayers.clear();
            updatePlayerConfigDisplay();
            updatePlayerFilterButtons(); // æ›´æ–°ç­›é€‰å™¨æŒ‰é’®çŠ¶æ€
            updatePlayerHighlights(); // æ›´æ–°æ¯”èµ›ä¸­ç©å®¶åå­—çš„é«˜äº®çŠ¶æ€
            applyMatchFilter();
            updateFilterStatus();
        }
        
        // æ›´æ–°ç­›é€‰çŠ¶æ€æ˜¾ç¤º
        function updateFilterStatus() {
            const filterStatus = document.getElementById('filterStatus');
            const clearFilterBtn = document.getElementById('clearFilterBtn');
            
            if (selectedPlayers.size === 0) {
                filterStatus.style.display = 'none';
                if (clearFilterBtn) clearFilterBtn.style.display = 'none';
                return;
            }
            
            const selectedNames = Array.from(selectedPlayers);
            const filteredMatches = getFilteredMatches();
            
            // æ˜¾ç¤ºç­›é€‰çŠ¶æ€
            filterStatus.style.display = 'block';
            filterStatus.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 10px;">
                    <div>
                        ğŸ” ç­›é€‰æ¡ä»¶ï¼š<strong>${selectedNames.join(' + ')}</strong>
                        <span class="filter-match-count">ï¼ˆæ˜¾ç¤º ${filteredMatches.length} åœºæ¯”èµ›ï¼‰</span>
                    </div>
                    <button class="filter-clear-btn" onclick="clearAllFilters()">âœ–ï¸ æ¸…é™¤ç­›é€‰</button>
                </div>
            `;
            
            // æ˜¾ç¤ºé¡¶éƒ¨æ¸…é™¤æŒ‰é’®
            if (clearFilterBtn) clearFilterBtn.style.display = 'block';
        }
        
        // è·å–ç­›é€‰åçš„æ¯”èµ›åˆ—è¡¨
        function getFilteredMatches() {
            if (selectedPlayers.size === 0) {
                return matchSchedule;
            }
            
            return matchSchedule.filter(match => {
                const allPlayersInMatch = [...match.team1, ...match.team2];
                // æ£€æŸ¥æ¯”èµ›ä¸­æ˜¯å¦åŒæ—¶åŒ…å«æ‰€æœ‰é€‰ä¸­çš„ç©å®¶
                return Array.from(selectedPlayers).every(playerName => 
                    allPlayersInMatch.includes(playerName)
                );
            });
        }
        
        // åº”ç”¨æ¯”èµ›ç­›é€‰
        function applyMatchFilter() {
            const filteredMatches = getFilteredMatches();
            const matchItems = document.querySelectorAll('.preview-match');
            
            matchSchedule.forEach((match, index) => {
                const matchItem = matchItems[index];
                if (matchItem) {
                    if (filteredMatches.includes(match)) {
                        matchItem.classList.remove('filtered-out');
                    } else {
                        matchItem.classList.add('filtered-out');
                    }
                }
            });

            // å¦‚æœæœ‰ç­›é€‰æ¡ä»¶ä½†æ²¡æœ‰åŒ¹é…çš„æ¯”èµ›ï¼Œæ˜¾ç¤ºæç¤º
            if (selectedPlayers.size > 0 && filteredMatches.length === 0) {
                showNoMatchesHint();
            } else {
                hideNoMatchesHint();
            }
        }

        // æ˜¾ç¤ºæ— åŒ¹é…æ¯”èµ›æç¤º
        function showNoMatchesHint() {
            const container = document.getElementById('matchesPreview');
            let hintDiv = document.getElementById('noMatchesHint');
            
            if (!hintDiv) {
                hintDiv = document.createElement('div');
                hintDiv.id = 'noMatchesHint';
                hintDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 255, 255, 0.95);
                    padding: 30px;
                    border-radius: 15px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
                    text-align: center;
                    z-index: 1000;
                    max-width: 300px;
                `;
                container.appendChild(hintDiv);
            }
            
            const selectedNames = Array.from(selectedPlayers);
            hintDiv.innerHTML = `
                <div style="font-size: 2rem; margin-bottom: 15px;">ğŸ”</div>
                <div style="font-weight: bold; margin-bottom: 10px; color: #dc3545;">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ¯”èµ›</div>
                <div style="font-size: 0.9rem; color: #666; margin-bottom: 15px;">
                    æ²¡æœ‰æ¯”èµ›åŒæ—¶åŒ…å«ï¼š<strong>${selectedNames.join(' + ')}</strong>
                </div>
                <button onclick="clearAllFilters()" style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer;">
                    æ¸…é™¤ç­›é€‰æ¡ä»¶
                </button>
            `;
            hintDiv.style.display = 'block';
        }

        // éšè—æ— åŒ¹é…æ¯”èµ›æç¤º
        function hideNoMatchesHint() {
            const hintDiv = document.getElementById('noMatchesHint');
            if (hintDiv) {
                hintDiv.style.display = 'none';
            }
        }

        // åˆ‡æ¢ç©å®¶å‚èµ›çŠ¶æ€
        function togglePlayer(index) {
            if (index < currentPlayerCount) {
                playerConfig[index].active = !playerConfig[index].active;
                updatePlayerConfigDisplay();
                updateFairnessDescription();
            }
        }

        // æ›´æ–°å…¬å¹³æ€§æè¿°
        function updateFairnessDescription() {
            const activeCount = getActivePlayers().length;
            const descElement = document.getElementById('fairnessDescription');
            
            if (activeCount === 5) {
                descElement.innerHTML = `
                    â€¢ <strong>5äººæ¨¡å¼</strong>ï¼š15åœºæ¯”èµ›ï¼Œæ¯äººå‚åŠ 12åœº<br>
                    â€¢ <strong>æ­æ¡£åˆ†é…</strong>ï¼šæ¯äººéƒ½èƒ½ä¸å…¶ä»–4äººæ­æ¡£<br>
                    â€¢ <strong>ä¼‘æ¯åˆ†å¸ƒ</strong>ï¼šæ¯äººæ€»å…±ä¼‘æ¯3åœºï¼Œå‡åŒ€åˆ†å¸ƒ<br>
                    â€¢ <strong>æ¯”èµ›å¼ºåº¦</strong>ï¼šé€‚ä¸­ï¼Œå®Œå…¨å…¬å¹³åˆ†é…
                `;
            } else if (activeCount === 6) {
                descElement.innerHTML = `
                    â€¢ <strong>6äººæ¨¡å¼</strong>ï¼š16åœºæ¯”èµ›ï¼Œæ¯äººå‚åŠ 10-11åœº<br>
                    â€¢ <strong>æ­æ¡£åˆ†é…</strong>ï¼š13ä¸ªæ­æ¡£ç»„åˆ2æ¬¡ï¼Œ2ä¸ªæ­æ¡£ç»„åˆ3æ¬¡<br>
                    â€¢ <strong>ä¼‘æ¯åˆ†å¸ƒ</strong>ï¼šæ¯äººä¼‘æ¯5-6åœºï¼Œåˆç†åˆ†æ•£<br>
                    â€¢ <strong>æ¯”èµ›æ—¶é•¿</strong>ï¼š2å°æ—¶40åˆ†é’Ÿï¼Œæœ€ä¼˜å…¬å¹³æ€§
                `;
            } else {
                descElement.innerHTML = `
                    â€¢ <strong>å½“å‰${activeCount}äºº</strong>ï¼šè¯·é€‰æ‹©5äººæˆ–6äººè¿›è¡Œæ¯”èµ›<br>
                    â€¢ ç³»ç»Ÿå°†è‡ªåŠ¨ç”Ÿæˆæœ€å…¬å¹³çš„è½®æ¢å®‰æ’
                `;
            }
        }

        // ä¿å­˜ç©å®¶é…ç½®
        function savePlayerConfig() {
            const activeCount = getActivePlayers().length;
            
            if (activeCount < 5 || activeCount > 6) {
                showAlert('è¯·ç¡®ä¿å‚èµ›äººæ•°ä¸º5äººæˆ–6äººï¼', 'âš ï¸ å‚èµ›äººæ•°é”™è¯¯', 'warning');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰é‡å
            const activeNames = getActivePlayers().map(p => p.name.trim());
            const uniqueNames = [...new Set(activeNames)];
            if (activeNames.length !== uniqueNames.length) {
                showAlert('å‚èµ›äººå‘˜ä¸­æœ‰é‡åï¼Œè¯·ä¿®æ”¹åå†ä¿å­˜ï¼', 'âš ï¸ å§“åé‡å¤', 'warning');
                return;
            }
            
            closePlayerConfigModal();
            updatePlayersDisplay();
            
            // ä¿å­˜ç©å®¶é…ç½®åˆ°äº‘ç«¯
            savePlayerConfigToCloud();
            
            // é‡æ–°ç”Ÿæˆæ¯”èµ›å®‰æ’
            generateRandomMatches();
            updateMatchDisplay();
            hideFinalRanking();
            
            window.lastActionType = 'update_players';
            if (saveToSync) saveToSync();
            
            showAlert(`âœ… é…ç½®å·²ä¿å­˜åˆ°äº‘ç«¯ï¼\n\nå½“å‰${activeCount}äººå‚èµ›æ¨¡å¼å·²ç”Ÿæ•ˆ`, 'é…ç½®æˆåŠŸ', 'success');
        }

        // ä¿å­˜ç©å®¶é…ç½®åˆ°äº‘ç«¯
        function savePlayerConfigToCloud() {
            if (!gameClass) {
                console.log('äº‘ç«¯å­˜å‚¨æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨');
                localStorage.setItem('playerConfig', JSON.stringify(playerConfig));
                return;
            }
            
            try {
                const configData = {
                    playerConfig: playerConfig,
                    timestamp: Date.now(),
                    lastUpdatedBy: window.currentUserId || 'anonymous'
                };
                
                // ä¿å­˜åˆ°LeanCloud
                const configObject = new gameClass();
                configObject.set('type', 'playerConfig');
                configObject.set('data', configData);
                configObject.save().then(() => {
                    console.log('âœ… ç©å®¶é…ç½®å·²ä¿å­˜åˆ°äº‘ç«¯');
                }).catch(error => {
                    console.error('âŒ äº‘ç«¯ä¿å­˜å¤±è´¥:', error);
                    // é™çº§åˆ°æœ¬åœ°å­˜å‚¨
                    localStorage.setItem('playerConfig', JSON.stringify(playerConfig));
                });
                
            } catch (error) {
                console.error('âŒ äº‘ç«¯ä¿å­˜å¼‚å¸¸:', error);
                localStorage.setItem('playerConfig', JSON.stringify(playerConfig));
            }
        }

        // ä»äº‘ç«¯åŠ è½½ç©å®¶é…ç½®
        function loadPlayerConfigFromCloud() {
            if (!gameClass) {
                console.log('äº‘ç«¯å­˜å‚¨æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨');
                const saved = localStorage.getItem('playerConfig');
                if (saved) {
                    try {
                        playerConfig = JSON.parse(saved);
                        updatePlayerConfigDisplay();
                        updatePlayersDisplay();
                        console.log('âœ… ä»æœ¬åœ°å­˜å‚¨åŠ è½½ç©å®¶é…ç½®');
                    } catch (error) {
                        console.error('âŒ æœ¬åœ°é…ç½®è§£æå¤±è´¥:', error);
                    }
                }
                return;
            }
            
            try {
                const query = new AV.Query(gameClass);
                query.equalTo('type', 'playerConfig');
                query.descending('updatedAt');
                query.first().then(result => {
                    if (result) {
                        const configData = result.get('data');
                        if (configData && configData.playerConfig) {
                            playerConfig = configData.playerConfig;
                            updatePlayerConfigDisplay();
                            updatePlayersDisplay();
                            console.log('âœ… ä»äº‘ç«¯åŠ è½½ç©å®¶é…ç½®');
                        }
                    } else {
                        console.log('äº‘ç«¯æ— é…ç½®æ•°æ®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®');
                    }
                }).catch(error => {
                    console.error('âŒ äº‘ç«¯åŠ è½½å¤±è´¥:', error);
                    // å°è¯•æœ¬åœ°å­˜å‚¨
                    const saved = localStorage.getItem('playerConfig');
                    if (saved) {
                        try {
                            playerConfig = JSON.parse(saved);
                            updatePlayerConfigDisplay();
                            updatePlayersDisplay();
                            console.log('âœ… ä»æœ¬åœ°å­˜å‚¨åŠ è½½ç©å®¶é…ç½®');
                        } catch (error) {
                            console.error('âŒ æœ¬åœ°é…ç½®è§£æå¤±è´¥:', error);
                        }
                    }
                });
                
            } catch (error) {
                console.error('âŒ äº‘ç«¯åŠ è½½å¼‚å¸¸:', error);
            }
        }

        // æ˜¾ç¤ºæ¯”èµ›å®‰æ’å¯è§†åŒ–
        function showScheduleVisualization() {
            if (matchSchedule.length === 0) {
                showAlert('è¯·å…ˆç”Ÿæˆæ¯”èµ›å®‰æ’ï¼', 'âš ï¸ æš‚æ— æ¯”èµ›æ•°æ®', 'warning');
                return;
            }
            
            generateScheduleVisualization();
            document.getElementById('scheduleModal').classList.add('active');
        }

        // å…³é—­æ¯”èµ›å®‰æ’å¯è§†åŒ–
        function closeScheduleModal() {
            document.getElementById('scheduleModal').classList.remove('active');
        }

        // ç”Ÿæˆæ¯”èµ›å®‰æ’å¯è§†åŒ–
        function generateScheduleVisualization() {
            const activePlayers = getActivePlayers();
            const overviewContainer = document.getElementById('scheduleOverview');
            const summaryContainer = document.getElementById('scheduleSummary');
            
            // ç”Ÿæˆè¯¦ç»†æ¯”èµ›å®‰æ’
            let overviewHTML = '';
            
            // æ·»åŠ å›¾ä¾‹
            overviewHTML += `
                <div class="schedule-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #28a745;"></div>
                        <span>æ¯”èµ›ä¸­</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #dc3545;"></div>
                        <span>ä¼‘æ¯ä¸­</span>
                    </div>
                </div>
            `;
            
            // ç”Ÿæˆæ¯ä¸ªäººçš„æ¯”èµ›å®‰æ’è¡¨æ ¼
            overviewHTML += '<div class="player-schedule-grid">';
            
            // è¡¨å¤´
            overviewHTML += '<div class="schedule-header">';
            overviewHTML += '<div class="schedule-player-name">å§“å</div>';
            for (let round = 1; round <= 3; round++) {
                for (let match = 1; match <= 5; match++) {
                    overviewHTML += `<div class="schedule-cell" style="background: #f8f9fa; color: #666; font-size: 0.6rem;">R${round}M${match}</div>`;
                }
            }
            overviewHTML += '</div>';
            
            // æ¯ä¸ªç©å®¶çš„è¡Œ
            activePlayers.forEach(player => {
                overviewHTML += `<div class="schedule-player-name">${player.name}</div>`;
                
            for (let round = 0; round < 3; round++) {
                for (let match = 0; match < 5; match++) {
                        const matchData = matchSchedule[round][match];
                        const isPlaying = [...matchData.team1, ...matchData.team2].includes(player.name);
                        
                        if (isPlaying) {
                            overviewHTML += `<div class="schedule-cell playing">âš½</div>`;
                        } else {
                            overviewHTML += `<div class="schedule-cell resting">ğŸ’¤</div>`;
                        }
                    }
                }
            });
            
            overviewHTML += '</div>';
            
            // è¯¦ç»†æ¯”èµ›å®‰æ’
            for (let round = 0; round < 3; round++) {
                overviewHTML += `
                    <div class="schedule-round">
                        <div class="schedule-round-title">ç¬¬${round + 1}è½®æ¯”èµ›</div>
                        <div class="schedule-matches">
                `;
                
                for (let match = 0; match < 5; match++) {
                    const matchData = matchSchedule[round][match];
                    const allPlayers = activePlayers.map(p => p.name);
                    const playingPlayers = [...matchData.team1, ...matchData.team2];
                    const restingPlayers = allPlayers.filter(p => !playingPlayers.includes(p));
                    
                    overviewHTML += `
                        <div class="schedule-match">
                            <div class="match-teams">
                                ${matchData.team1.join(' + ')} VS ${matchData.team2.join(' + ')}
                            </div>
                            <div class="match-rest">
                                ä¼‘æ¯ï¼š${restingPlayers.join(', ')}
                            </div>
                        </div>
                    `;
                }
                
                overviewHTML += '</div></div>';
            }
            
            overviewContainer.innerHTML = overviewHTML;
            
            // ç”Ÿæˆç»Ÿè®¡æ‘˜è¦
            const stats = calculatePlayerStats();
            let summaryHTML = '<div style="font-weight: 600; margin-bottom: 10px;">ğŸ“Š å‚èµ›ç»Ÿè®¡æ‘˜è¦</div>';
            
            summaryHTML += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">';
            
            activePlayers.forEach(player => {
                const playerStats = stats[player.name];
                summaryHTML += `
                    <div style="background: white; padding: 10px; border-radius: 8px; border: 1px solid #ddd;">
                        <div style="font-weight: 600; color: #2c3e50; margin-bottom: 5px;">${player.name}</div>
                        <div style="font-size: 0.8rem; color: #666;">
                            æ¯”èµ›ï¼š${playerStats.totalMatches} åœº<br>
                            ä¼‘æ¯ï¼š${playerStats.totalRests} åœº<br>
                            æ­æ¡£ï¼š${playerStats.partners.length} äºº
                        </div>
                    </div>
                `;
            });
            
            summaryHTML += '</div>';
            
            // æ·»åŠ å…¬å¹³æ€§åˆ†æ
            summaryHTML += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">';
            summaryHTML += '<div style="font-weight: 600; margin-bottom: 8px;">âš–ï¸ å…¬å¹³æ€§åˆ†æ</div>';
            
            const matchCounts = Object.values(stats).map(s => s.totalMatches);
            const restCounts = Object.values(stats).map(s => s.totalRests);
            
            const minMatches = Math.min(...matchCounts);
            const maxMatches = Math.max(...matchCounts);
            const minRests = Math.min(...restCounts);
            const maxRests = Math.max(...restCounts);
            
            summaryHTML += `
                <div style="font-size: 0.85rem; color: #495057;">
                    â€¢ æ¯”èµ›åœºæ¬¡èŒƒå›´ï¼š${minMatches} - ${maxMatches} åœº<br>
                    â€¢ ä¼‘æ¯åœºæ¬¡èŒƒå›´ï¼š${minRests} - ${maxRests} åœº<br>
                    â€¢ å…¬å¹³æ€§è¯„çº§ï¼š${maxMatches - minMatches <= 1 ? 'âœ… ä¼˜ç§€' : 'âš ï¸ éœ€è¦ä¼˜åŒ–'}
                </div>
            `;
            
            summaryHTML += '</div>';
            
            summaryContainer.innerHTML = summaryHTML;
        }

        // è®¡ç®—ç©å®¶ç»Ÿè®¡æ•°æ®
        function calculatePlayerStats() {
            const activePlayers = getActivePlayers();
            const stats = {};
            
            activePlayers.forEach(player => {
                stats[player.name] = {
                    totalMatches: 0,
                    totalRests: 0,
                    partners: new Set(),
                    opponents: new Set()
                };
            });
            
            for (let round = 0; round < 3; round++) {
                for (let match = 0; match < 5; match++) {
                    const matchData = matchSchedule[round][match];
                    const allPlayers = activePlayers.map(p => p.name);
                    const playingPlayers = [...matchData.team1, ...matchData.team2];
                    
                    // ç»Ÿè®¡æ¯”èµ›å’Œä¼‘æ¯
                    allPlayers.forEach(playerName => {
                        if (playingPlayers.includes(playerName)) {
                            stats[playerName].totalMatches++;
                } else {
                            stats[playerName].totalRests++;
                        }
                    });
                    
                    // ç»Ÿè®¡æ­æ¡£å…³ç³»
                    matchData.team1.forEach(player1 => {
                        matchData.team1.forEach(player2 => {
                            if (player1 !== player2) {
                                stats[player1].partners.add(player2);
                            }
                        });
                        matchData.team2.forEach(opponent => {
                            stats[player1].opponents.add(opponent);
                        });
                    });
                    
                    matchData.team2.forEach(player1 => {
                        matchData.team2.forEach(player2 => {
                            if (player1 !== player2) {
                                stats[player1].partners.add(player2);
                            }
                        });
                        matchData.team1.forEach(opponent => {
                            stats[player1].opponents.add(opponent);
                        });
                    });
                }
            }
            
            // è½¬æ¢Setä¸ºæ•°ç»„
            Object.keys(stats).forEach(playerName => {
                stats[playerName].partners = Array.from(stats[playerName].partners);
                stats[playerName].opponents = Array.from(stats[playerName].opponents);
            });
            
            return stats;
        }

        // æ›´æ–°15åœºæ¯”èµ›æ˜¾ç¤º - ç›´æ¥å¹³é“º
        function updateMatchDisplay() {
            const container = document.getElementById('matchesPreview');
            container.innerHTML = '';
            
            // æ¸…é™¤åˆå§‹åŠ è½½æç¤º
            const initialLoading = document.getElementById('initialLoading');
            if (initialLoading) {
                initialLoading.remove();
            }
            
            if (!matchSchedule || matchSchedule.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">è¯·å…ˆç”Ÿæˆæ¯”èµ›å®‰æ’</div>';
                return;
            }
            
            // ç›´æ¥å¹³é“ºæ‰€æœ‰15åœºæ¯”èµ›
            const allMatchesDiv = document.createElement('div');
            allMatchesDiv.className = 'all-matches-container';
            allMatchesDiv.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 10px;
                margin: 20px 0;
            `;
            
            matchSchedule.forEach((matchData, matchIndex) => {
                const matchDiv = document.createElement('div');
                matchDiv.className = 'preview-match';
                matchDiv.onclick = () => openMatchScore(matchIndex);
                
                const score1 = matchData.score1;
                const score2 = matchData.score2;
                
                if (score1 > 0 || score2 > 0) {
                    matchDiv.classList.add('completed');
                }
                
                // åˆ›å»ºå¯ç‚¹å‡»çš„ç©å®¶åå­—
                const createClickablePlayerNames = (players) => {
                    return players.map(playerName => {
                        const isSelected = selectedPlayers.has(playerName);
                        return `<span class="clickable-player-name ${isSelected ? 'selected' : ''}" onclick="event.stopPropagation(); togglePlayerFilter('${playerName}')">${playerName}</span>`;
                    }).join(' + ');
                };
                
                matchDiv.innerHTML = `
                    <div class="match-text">
                        <div style="font-weight: bold; margin-bottom: 5px;">ç¬¬${matchIndex + 1}åœºæ¯”èµ›</div>
                        <div>${createClickablePlayerNames(matchData.team1)} VS ${createClickablePlayerNames(matchData.team2)}</div>
                    </div>
                    <span class="match-score ${score1 > 0 || score2 > 0 ? 'has-score' : ''}" onclick="event.stopPropagation(); openMatchScore(${matchIndex})">${score1} : ${score2}</span>
                `;
                
                allMatchesDiv.appendChild(matchDiv);
            });
            
            container.appendChild(allMatchesDiv);
            
            // åº”ç”¨ç­›é€‰ï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå·²æ›´æ–°ï¼‰
            setTimeout(() => {
                applyMatchFilter();
                updateFilterStatus();
            }, 0);
        }

        // æ›´æ–°æ¯”èµ›æ–‡æœ¬
        function updateMatchTexts() {
            const matchTexts = document.querySelectorAll('.preview-match .match-text');
            matchTexts.forEach((textElement, index) => {
                const round = Math.floor(index / 5);
                const match = index % 5;
                const matchData = matchSchedule[round] && matchSchedule[round][match];
                
                if (matchData) {
                    textElement.textContent = `${matchData.team1.join(' + ')} VS ${matchData.team2.join(' + ')}`;
                }
            });
        }

        // å…¨å±€å˜é‡å£°æ˜
        let gameClass = null;

        // LeanCloudå®æ—¶åŒæ­¥ï¼ˆå›½å†…æœ€ä½³æ–¹æ¡ˆï¼‰
        function initSimpleJsonSync() {
            // LeanCloudé…ç½®ï¼ˆæ¼”ç¤ºé…ç½®ï¼Œæ‚¨å¯ä»¥åˆ›å»ºè‡ªå·±çš„ï¼‰
            const leancloudConfig = {
                appId: 'sHFMtBnumqNruNtqiQFGNuah-gzGzoHsz',
                appKey: 'OQLGQDKCo48oayq0OAnd8g5K',
                serverURL: 'https://shfmtbnu.lc-cn-n1-shared.com'
            };
            
            let lastSyncTime = 0;
            
            // åˆå§‹åŒ–LeanCloud
            async function init() {
                try {
                    // æ£€æŸ¥ AV æ˜¯å¦å¯ç”¨
                    if (typeof AV === 'undefined') {
                        throw new Error('LeanCloud SDK æœªåŠ è½½');
                    }
                    
                    showLoading('æ­£åœ¨è¿æ¥äº‘ç«¯...', 'è¿æ¥LeanCloudå®æ—¶æ•°æ®åº“');
                    
                    // åˆå§‹åŒ–LeanCloud
                    AV.init(leancloudConfig);
                    
                    // åˆ›å»ºæ•°æ®ç±»
                    gameClass = AV.Object.extend('BadmintonGame');
                    
                    // ä»äº‘ç«¯åŠ è½½æ•°æ®
                    await loadFromCloud();
                    
                    // è®¾ç½®å®æ—¶ç›‘å¬
                    setupRealtimeListener();
                    
                    isConnected = true;
                    hideLoading();
                    showSyncNotification('ğŸ‰ LeanCloudè¿æ¥æˆåŠŸï¼å®æ—¶åŒæ­¥å·²å¼€å¯');
                    
                } catch (error) {
                    console.error('LeanCloudè¿æ¥å¤±è´¥:', error);
                    isConnected = false;
                    hideLoading();
                    
                    // ä½¿ç”¨æ¼”ç¤ºæ¨¡å¼
                    initDemoMode();
                    
                    showSyncNotification('âš ï¸ LeanCloudè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨æ¼”ç¤ºæ¨¡å¼ï¼ˆæ•°æ®ä»…æœ¬åœ°ä¿å­˜ï¼‰', 'warning');
                }
            }
            
            // æ¼”ç¤ºæ¨¡å¼ï¼ˆæ¨¡æ‹Ÿå®æ—¶åŒæ­¥ï¼‰
            function initDemoMode() {
                debugLog('å¯åŠ¨æ¼”ç¤ºæ¨¡å¼');
                
                // ç¡®ä¿æœ‰æ¯”èµ›æ•°æ®
                if (!matchSchedule || matchSchedule.length === 0) {
                    debugLog('ç”Ÿæˆæ¼”ç¤ºæ¯”èµ›æ•°æ®');
                    generateRandomMatches();
                }
                
                debugLog('æ›´æ–°æ˜¾ç¤º');
                updatePlayersDisplay();
                updateMatchDisplay();
                
                // æ¨¡æ‹Ÿå®æ—¶åŒæ­¥çš„æœ¬åœ°ç‰ˆæœ¬
                let syncData = {
                    matchSchedule: matchSchedule,
                    timestamp: Date.now(),
                    lastUpdatedBy: window.currentUserId
                };
                
                // ä¿å­˜å‡½æ•°
                saveToSync = function() {
                    syncData = {
                        matchSchedule: matchSchedule,
                        finalRankingVisible: document.getElementById('finalRanking').style.display !== 'none',
                        timestamp: Date.now(),
                        lastUpdatedBy: window.currentUserId,
                        actionType: window.lastActionType
                    };
                    
                    // ä¿å­˜åˆ°localStorage
                    localStorage.setItem('badminton-realtime-demo', JSON.stringify(syncData));
                    
                    showSyncNotification('ğŸ“Š æ¯”åˆ†å·²æ›´æ–°ï¼ˆæ¼”ç¤ºæ¨¡å¼ï¼‰');
                    
                    // æ¨¡æ‹Ÿå…¶ä»–ç”¨æˆ·çš„æ›´æ–°é€šçŸ¥
                    setTimeout(() => {
                        const actions = {
                            'score_update': 'ğŸ“Š æ¨¡æ‹Ÿï¼šå…¶ä»–äººçœ‹åˆ°äº†æ¯”åˆ†æ›´æ–°',
                            'regenerate_matches': 'ğŸ² æ¨¡æ‹Ÿï¼šå…¶ä»–äººçœ‹åˆ°äº†é‡æ–°å¼€å§‹',
                            'show_ranking': 'ğŸ† æ¨¡æ‹Ÿï¼šå…¶ä»–äººçœ‹åˆ°äº†æ’å'
                        };
                        showSyncNotification(actions[window.lastActionType] || 'ğŸ“Š æ¨¡æ‹ŸåŒæ­¥å®Œæˆ');
                    }, 2000);
                };
                
                // æ£€æŸ¥æœ¬åœ°æ•°æ®
                try {
                    const stored = localStorage.getItem('badminton-realtime-demo');
                    if (stored) {
                        const data = JSON.parse(stored);
                        if (data.matchSchedule) {
                            matchSchedule = data.matchSchedule;
                            updateMatchDisplay();
                            
                            if (data.finalRankingVisible) {
                                document.getElementById('finalRanking').style.display = 'block';
                            }
                            
                            showSyncNotification('ğŸ“Š åŠ è½½äº†ä¹‹å‰çš„æ¯”èµ›æ•°æ®');
                        }
                    }
                } catch (e) {
                    console.log('æ•°æ®åŠ è½½å¤±è´¥');
                }
            }
            
            // ä¿å­˜åˆ°LeanCloudï¼ˆæ›´æ–°ç°æœ‰è®°å½•ï¼‰
            async function save() {
                if (!gameClass) {
                    console.log('LeanCloudæœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æ¼”ç¤ºæ¨¡å¼');
                return;
            }

                try {
                    showLoading('æ­£åœ¨åŒæ­¥...', 'ä¿å­˜æ¯”åˆ†åˆ°äº‘ç«¯æ•°æ®åº“');
                    
                    const gameData = {
                        matchSchedule: matchSchedule,
                        finalRankingVisible: document.getElementById('finalRanking').style.display !== 'none',
                        timestamp: Date.now(),
                        lastUpdatedBy: window.currentUserId,
                        actionType: window.lastActionType || 'score_update'
                    };
                    
                    // å…ˆæŸ¥æ‰¾ç°æœ‰è®°å½•
                    const query = new AV.Query(gameClass);
                    query.equalTo('gameId', 'current_game');
                    const results = await query.find();
                    
                    let gameObject;
                    if (results.length > 0) {
                        // æ›´æ–°ç°æœ‰è®°å½•
                        gameObject = results[0];
                    } else {
                        // åˆ›å»ºæ–°è®°å½•
                        gameObject = new gameClass();
                        gameObject.set('gameId', 'current_game');
                    }
                    
                    gameObject.set('data', gameData);
                    await gameObject.save();
                    
                    lastSyncTime = gameData.timestamp;
                    hideLoading();
                    showSyncNotification('â˜ï¸ æ¯”åˆ†å·²å®æ—¶åŒæ­¥');
                    
                } catch (error) {
                    console.error('LeanCloudä¿å­˜å¤±è´¥:', error);
                    hideLoading();
                    showSyncNotification('âŒ ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                }
            }
            
            // ä»LeanCloudåŠ è½½æ•°æ®
            async function loadFromCloud() {
                if (!gameClass) return;
                
                try {
                    showLoading('æ­£åœ¨åŠ è½½æ•°æ®...', 'ä»äº‘ç«¯è·å–æœ€æ–°æ¯”åˆ†æ•°æ®');
                    
                    const query = new AV.Query(gameClass);
                    query.equalTo('gameId', 'current_game');
                    query.descending('updatedAt');
                    query.limit(1);
                    
                    const results = await query.find();
                    
                    if (results.length > 0) {
                        const gameData = results[0].get('data');
                        
                        if (gameData && gameData.matchSchedule) {
                            matchSchedule = gameData.matchSchedule;
                            lastSyncTime = gameData.timestamp || 0;
                            updateMatchDisplay();
                            
                            if (gameData.finalRankingVisible) {
                                document.getElementById('finalRanking').style.display = 'block';
                            }
                            
                            hideLoading();
                            showSyncNotification('ğŸ“Š äº‘ç«¯æ•°æ®åŠ è½½å®Œæˆ');
                        } else {
                            hideLoading();
                            generateRandomMatches();
                            updateMatchDisplay();
                            showSyncNotification('ğŸ² ç”Ÿæˆäº†æ–°çš„æ¯”èµ›å®‰æ’');
                        }
                    } else {
                        // äº‘ç«¯æ²¡æœ‰æ•°æ®ï¼Œç”Ÿæˆæ–°æ¯”èµ›
                        hideLoading();
                        generateRandomMatches();
                        updateMatchDisplay();
                        showSyncNotification('ğŸ² ç”Ÿæˆäº†æ–°çš„æ¯”èµ›å®‰æ’');
                    }
                    
                } catch (error) {
                    console.error('LeanCloudåŠ è½½å¤±è´¥:', error);
                    hideLoading();
                    generateRandomMatches();
                    updateMatchDisplay();
                    showSyncNotification('âš ï¸ åŠ è½½å¤±è´¥ï¼Œç”Ÿæˆæ–°æ¯”èµ›');
                }
            }
            
            // è®¾ç½®å®æ—¶ç›‘å¬ï¼ˆä½¿ç”¨è½®è¯¢ç¡®ä¿å¯é æ€§ï¼‰
            function setupRealtimeListener() {
                if (!gameClass) return;
                
                // æ¯10ç§’æ£€æŸ¥äº‘ç«¯æ›´æ–°ï¼ˆé™ä½é¢‘ç‡é¿å…è¶…è¿‡LeanCloudé™åˆ¶ï¼‰
                setInterval(async () => {
                    try {
                        const query = new AV.Query(gameClass);
                        query.equalTo('gameId', 'current_game');
                        query.descending('updatedAt');
                        query.limit(1);
                        
                        const results = await query.find();
                        
                        if (results.length > 0) {
                            const gameData = results[0].get('data');
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ•°æ®
                            if (gameData && gameData.timestamp > lastSyncTime && 
                                gameData.lastUpdatedBy !== window.currentUserId) {
                                
                                lastSyncTime = gameData.timestamp;
                                
                                // æ›´æ–°æ¯”èµ›æ•°æ®
                                matchSchedule = gameData.matchSchedule;
                                updateMatchDisplay();
                                
                                // æ›´æ–°æ’åæ˜¾ç¤ºçŠ¶æ€
                                if (gameData.finalRankingVisible) {
                                    document.getElementById('finalRanking').style.display = 'block';
                                } else {
                                    document.getElementById('finalRanking').style.display = 'none';
                                }
                                
                                // æ˜¾ç¤ºå®æ—¶æ›´æ–°æç¤º - æ›´æ˜æ˜¾çš„é€šçŸ¥
                                const actions = {
                                    'score_update': 'ğŸ”¥ æœ‰äººä¿®æ”¹äº†æ¯”åˆ†ï¼',
                                    'regenerate_matches': 'ğŸ² æœ‰äººé‡æ–°å¼€å§‹äº†æ¯”èµ›',
                                    'show_ranking': 'ğŸ† æœ‰äººæŸ¥çœ‹äº†æ’å',
                                    'hide_ranking': 'âŒ æœ‰äººå…³é—­äº†æ’å'
                                };
                                
                                const notificationMessage = actions[gameData.actionType] || 'ğŸ“Š å®æ—¶æ•°æ®æ›´æ–°';
                                showSyncNotification(notificationMessage);
                                
                                // å¦‚æœæ˜¯æ¯”åˆ†æ›´æ–°ï¼Œæ˜¾ç¤ºæ›´æ˜æ˜¾çš„æç¤º
                                if (gameData.actionType === 'score_update') {
                                    showAlert('ğŸ”¥ æœ‰äººä¿®æ”¹äº†æ¯”åˆ†ï¼\n\né¡µé¢æ•°æ®å·²è‡ªåŠ¨æ›´æ–°', 'æ¯”åˆ†æ›´æ–°æé†’', 'info');
                                }
                            }
                        }
                        
                    } catch (error) {
                        console.log('å®æ—¶æ£€æŸ¥å¤±è´¥:', error);
                    }
                }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡ï¼Œé™ä½é¢‘ç‡é¿å…è¶…è¿‡ä½¿ç”¨é™åˆ¶
                
                showSyncNotification('ğŸ”¥ å®æ—¶ç›‘å¬å·²å¼€å¯ï¼ˆ10ç§’æ£€æŸ¥ï¼‰');
            }
            
            
            init();
            return save;
        }

        // æ‰“å¼€æ¯”åˆ†é€‰æ‹©å™¨
        function openMatchScore(matchIndex) {
            selectedRound = 0; // ä¸å†ä½¿ç”¨è½®æ¬¡æ¦‚å¿µ
            selectedMatch = matchIndex;
            
            const matchData = matchSchedule[matchIndex];
            if (!matchData) return;

            team1Score = matchData.score1;
            team2Score = matchData.score2;
            team1ScoreSet = matchData.score1 > 0;
            team2ScoreSet = matchData.score2 > 0;

            document.getElementById('advancedScoreTitle').textContent = `ç¬¬${matchIndex + 1}åœºæ¯”èµ›`;
            document.getElementById('team1Name').textContent = matchData.team1.join(' + ');
            document.getElementById('team2Name').textContent = matchData.team2.join(' + ');

            createScoreWheel('scoreWheel1', team1Score);
            createScoreWheel('scoreWheel2', team2Score);
            updateScoreStatus();

            document.getElementById('advancedScoreModal').classList.add('active');
        }

        // åˆ›å»ºæ¯”åˆ†è½®æ’­ï¼ˆ0-25åˆ†ï¼Œæ”¯æŒä¸Šæ‹‰å¿«é€Ÿåˆ°è¾¾é«˜åˆ†ï¼‰
        function createScoreWheel(wheelId, currentScore) {
            const wheel = document.getElementById(wheelId);
            wheel.innerHTML = '';

            // æ”¹ä¸º0-21åˆ†èŒƒå›´ï¼ˆç¾½æ¯›çƒæ ‡å‡†ï¼‰
            for (let i = 0; i <= 21; i++) {
                const scoreItem = document.createElement('div');
                scoreItem.className = 'score-item';
                scoreItem.textContent = i;
                scoreItem.onclick = () => selectWheelScore(wheelId, i);
                wheel.appendChild(scoreItem);
            }

            setWheelPosition(wheelId, currentScore);
        }

        // è®¾ç½®è½®æ’­ä½ç½®
        function setWheelPosition(wheelId, score) {
            const wheel = document.getElementById(wheelId);
            const items = wheel.children;
            
            const offset = -score * 40 + 40;
            wheel.style.transform = `translateY(${offset}px)`;

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const distance = Math.abs(i - score);
                
                item.classList.remove('center', 'adjacent', 'distant');
                
                if (distance === 0) {
                    item.classList.add('center');
                } else if (distance === 1) {
                    item.classList.add('adjacent');
                } else {
                    item.classList.add('distant');
                }
            }
        }

        // é€‰æ‹©åˆ†æ•°
        function selectWheelScore(wheelId, score) {
            if (wheelId === 'scoreWheel1') {
                team1Score = score;
                team1ScoreSet = true;
            } else {
                team2Score = score;
                team2ScoreSet = true;
            }

            setWheelPosition(wheelId, score);
            updateScoreStatus();
        }

        // è§¦æ‘¸å¤„ç†ï¼ˆä¼˜åŒ–ä¸Šæ‹‰æ“ä½œï¼Œæ”¯æŒå¿«é€Ÿåˆ°è¾¾é«˜åˆ†ï¼‰
        function handleTouchStart(event, teamIndex) {
            event.preventDefault();
            touchStartY = event.touches[0].clientY;
            isDragging = true;
        }

        function handleTouchMove(event, teamIndex) {
            if (!isDragging) return;
            event.preventDefault();
            
            const currentY = event.touches[0].clientY;
            const deltaY = touchStartY - currentY;
            
            // ä¼˜åŒ–çµæ•åº¦ï¼šä¸Šæ‹‰æ—¶æ›´çµæ•ï¼Œä¾¿äºå¿«é€Ÿåˆ°è¾¾21åˆ†ç­‰é«˜åˆ†
            let sensitivity = 40;
            if (deltaY > 0) { // ä¸Šæ‹‰æ—¶é™ä½çµæ•åº¦ï¼Œæ›´å®¹æ˜“æ»‘åŠ¨
                sensitivity = 30;
            }
            
            const scoreChange = Math.round(deltaY / sensitivity);
            if (Math.abs(scoreChange) >= 1) {
                const currentScore = teamIndex === 0 ? team1Score : team2Score;
                // æ›´æ–°ä¸º0-25åˆ†èŒƒå›´
                const newScore = Math.max(0, Math.min(21, currentScore + scoreChange));
                
                selectWheelScore(teamIndex === 0 ? 'scoreWheel1' : 'scoreWheel2', newScore);
                touchStartY = currentY;
            }
        }

        function handleTouchEnd(event, teamIndex) {
            isDragging = false;
        }

        function handleMouseDown(event, teamIndex) {
            event.preventDefault();
            touchStartY = event.clientY;
            isDragging = true;
        }

        function handleMouseMove(event, teamIndex) {
            if (!isDragging) return;
            event.preventDefault();
            
            const currentY = event.clientY;
            const deltaY = touchStartY - currentY;
            
            // ä¼˜åŒ–é¼ æ ‡æ»šåŠ¨çµæ•åº¦ï¼šä¸Šæ»‘æ—¶æ›´çµæ•
            let sensitivity = 40;
            if (deltaY > 0) { // ä¸Šæ»‘æ—¶é™ä½çµæ•åº¦ï¼Œæ›´å®¹æ˜“æ»‘åŠ¨
                sensitivity = 30;
            }
            
            const scoreChange = Math.round(deltaY / sensitivity);
            if (Math.abs(scoreChange) >= 1) {
                const currentScore = teamIndex === 0 ? team1Score : team2Score;
                // æ›´æ–°ä¸º0-25åˆ†èŒƒå›´
                const newScore = Math.max(0, Math.min(21, currentScore + scoreChange));
                
                selectWheelScore(teamIndex === 0 ? 'scoreWheel1' : 'scoreWheel2', newScore);
                touchStartY = currentY;
            }
        }

        function handleMouseUp(event, teamIndex) {
            isDragging = false;
        }

        // å¤„ç†æ»šè½®äº‹ä»¶ï¼Œæ”¯æŒå‘ä¸Šå‘ä¸‹æ»šåŠ¨
        function handleWheelScroll(event, teamIndex) {
            event.preventDefault();
            event.stopPropagation();
            
            const currentScore = teamIndex === 0 ? team1Score : team2Score;
            let newScore = currentScore;
            
            // å‘ä¸Šæ»šåŠ¨ï¼ˆdeltaY < 0ï¼‰å¢åŠ åˆ†æ•°ï¼Œå‘ä¸‹æ»šåŠ¨ï¼ˆdeltaY > 0ï¼‰å‡å°‘åˆ†æ•°
            if (event.deltaY < 0) {
                // å‘ä¸Šæ»šåŠ¨ï¼Œå¢åŠ åˆ†æ•°
                newScore = Math.min(21, currentScore + 1);
            } else if (event.deltaY > 0) {
                // å‘ä¸‹æ»šåŠ¨ï¼Œå‡å°‘åˆ†æ•°
                newScore = Math.max(0, currentScore - 1);
            }
            
            if (newScore !== currentScore) {
                selectWheelScore(teamIndex === 0 ? 'scoreWheel1' : 'scoreWheel2', newScore);
            }
        }

        // æ›´æ–°æ¯”åˆ†çŠ¶æ€
        function updateScoreStatus() {
            const statusElement = document.getElementById('scoreStatus');
            const saveBtn = document.getElementById('saveScoresBtn');

            if (team1ScoreSet && team2ScoreSet) {
                statusElement.textContent = `æ¯”åˆ†è®¾ç½®å®Œæˆï¼š${team1Score} : ${team2Score}`;
                statusElement.className = 'score-status complete';
                saveBtn.disabled = false;
            } else if (team1ScoreSet) {
                statusElement.textContent = `å·¦ä¾§å·²è®¾ç½®ï¼š${team1Score}åˆ†ï¼Œè¯·è®¾ç½®å³ä¾§æ¯”åˆ†`;
                statusElement.className = 'score-status';
                saveBtn.disabled = true;
            } else if (team2ScoreSet) {
                statusElement.textContent = `å³ä¾§å·²è®¾ç½®ï¼š${team2Score}åˆ†ï¼Œè¯·è®¾ç½®å·¦ä¾§æ¯”åˆ†`;
                statusElement.className = 'score-status';
                saveBtn.disabled = true;
            } else {
                statusElement.textContent = 'è¯·æ»‘åŠ¨ã€æ»šè½®æˆ–ç‚¹å‡»æ•°å­—è®¾ç½®åŒæ–¹æ¯”åˆ†ï¼ˆ0-21åˆ†ï¼Œæ”¯æŒå‘ä¸Šæ»šåŠ¨ï¼‰';
                statusElement.className = 'score-status';
                saveBtn.disabled = true;
            }
        }

        // ä¿å­˜æ¯”åˆ†
        function saveMatchScores() {
            if (!team1ScoreSet || !team2ScoreSet) {
                showAlert('è¯·ä¸ºåŒæ–¹é˜Ÿä¼éƒ½è®¾ç½®æ¯”åˆ†ï¼', 'âš ï¸ è®¾ç½®ä¸å®Œæ•´', 'warning');
                return;
            }

            const matchData = matchSchedule[selectedMatch];
            matchData.score1 = team1Score;
            matchData.score2 = team2Score;

            updateMatchDisplay();
            closeAdvancedScoreModal();
            
            window.lastActionType = 'score_update';
            if (saveToSync) saveToSync();
            
            showAlert(`ç¬¬${selectedMatch + 1}åœºæ¯”åˆ†å·²ä¿å­˜ï¼š${team1Score} : ${team2Score}`, 'âœ… ä¿å­˜æˆåŠŸ', 'success');
        }

        // å…³é—­æ¯”åˆ†é€‰æ‹©å™¨
        function closeAdvancedScoreModal() {
            document.getElementById('advancedScoreModal').classList.remove('active');
            team1ScoreSet = false;
            team2ScoreSet = false;
        }

        // é‡æ–°å¼€å§‹æ¯”èµ›
        function regenerateMatches() {
            showConfirm(
                'ç¡®å®šè¦é‡æ–°å¼€å§‹æ¯”èµ›å—ï¼Ÿ\nè¿™å°†é‡æ–°éšæœºå®‰æ’é˜Ÿå‹å¹¶æ¸…é™¤æ‰€æœ‰æ¯”åˆ†ã€‚',
                'ğŸ² é‡æ–°å¼€å§‹æ¯”èµ›',
                () => {
                    generateRandomMatches();
                    updatePlayersDisplay();
                    updateMatchDisplay();
                    hideFinalRanking();
                    
                    window.lastActionType = 'regenerate_matches';
                    if (saveToSync) saveToSync();
                    
                    showAlert('ğŸ‰ æ¯”èµ›å·²é‡æ–°å®‰æ’ï¼', 'å®‰æ’å®Œæˆ', 'success');
                }
            );
        }

        // æ˜¾ç¤ºæ’å
        function showFinalRanking() {
            const incompleteMatches = [];
            
            matchSchedule.forEach((matchData, matchIndex) => {
                if (matchData.score1 === 0 && matchData.score2 === 0) {
                        incompleteMatches.push({
                        matchIndex: matchIndex,
                        matchData: matchData
                    });
                }
            });

            // ä¿®æ”¹é€»è¾‘ï¼šå…è®¸æŸ¥çœ‹ä¸´æ—¶æ’åï¼Œä½†æä¾›æç¤ºä¿¡æ¯
            if (incompleteMatches.length > 0) {
                const completedMatches = matchSchedule.length - incompleteMatches.length;
                showAlert(
                    `å½“å‰æ˜¾ç¤ºä¸´æ—¶æ’åï¼ˆåŸºäºå·²å®Œæˆçš„ ${completedMatches} åœºæ¯”èµ›ï¼‰\n\nè¿˜æœ‰ ${incompleteMatches.length} åœºæ¯”èµ›æœªè®°å½•æ¯”åˆ†ï¼Œæ’åå¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚`,
                    'ğŸ“Š ä¸´æ—¶æ’å',
                    'info'
                );
            }

            calculateAndDisplayResults(incompleteMatches.length > 0);
            document.getElementById('finalRanking').style.display = 'block';
            
            window.lastActionType = 'show_ranking';
            if (saveToSync) saveToSync();
        }

        // éšè—æ’å
        function hideFinalRanking() {
            document.getElementById('finalRanking').style.display = 'none';
            window.lastActionType = 'hide_ranking';
            if (saveToSync) saveToSync();
        }

        // è®¡ç®—æ’å
        function calculateAndDisplayResults(isTemporary = false) {
            const activePlayers = getActivePlayers();
            const playerStats = {};
            
            activePlayers.forEach(player => {
                playerStats[player.name] = {
                    wins: 0,
                    losses: 0,
                    totalScore: 0,
                    totalOpponentScore: 0
                };
            });

            // ç»Ÿè®¡å·²å®Œæˆæ¯”èµ›çš„æ•°é‡
            let completedMatches = 0;
            matchSchedule.forEach(match => {
                    if (match.score1 > 0 || match.score2 > 0) {
                        completedMatches++;
                        match.team1.forEach(player => {
                        if (playerStats[player]) {
                            playerStats[player].totalScore += match.score1;
                            playerStats[player].totalOpponentScore += match.score2;
                            if (match.score1 > match.score2) {
                                playerStats[player].wins += 1;
                            } else if (match.score1 < match.score2) {
                                playerStats[player].losses += 1;
                            }
                            }
                        });

                        match.team2.forEach(player => {
                        if (playerStats[player]) {
                            playerStats[player].totalScore += match.score2;
                            playerStats[player].totalOpponentScore += match.score1;
                            if (match.score2 > match.score1) {
                                playerStats[player].wins += 1;
                            } else if (match.score2 < match.score1) {
                                playerStats[player].losses += 1;
                            }
                            }
                        });
                    }
            });

            const sortedPlayers = Object.entries(playerStats).sort((a, b) => {
                if (b[1].wins !== a[1].wins) return b[1].wins - a[1].wins;
                return (b[1].totalScore - b[1].totalOpponentScore) - (a[1].totalScore - a[1].totalOpponentScore);
            });

            const resultsGrid = document.getElementById('resultsGrid');
            
            // æ ¹æ®æ˜¯å¦ä¸ºä¸´æ—¶æ’åæ˜¾ç¤ºä¸åŒçš„æ ‡é¢˜
            const headerTitle = isTemporary ? 
                `<div style="text-align: center; margin-bottom: 10px; color: #f39c12; font-weight: bold;">
                    ğŸ“Š ä¸´æ—¶æ’å (åŸºäºå·²å®Œæˆçš„ ${completedMatches}/${matchSchedule.length} åœºæ¯”èµ›)
                </div>` : '';
            
            resultsGrid.innerHTML = headerTitle + `
                <div class="result-row header">
                    <div class="rank-cell">æ’å</div>
                    <div class="name-cell">å§“å</div>
                    <div class="score-cell">èƒœåœº</div>
                    <div class="score-cell">è´Ÿåœº</div>
                    <div class="score-cell">å‡€èƒœåˆ†</div>
                </div>
            `;

            sortedPlayers.forEach(([player, stats], index) => {
                const row = document.createElement('div');
                row.className = `result-row ${index === 0 ? 'winner' : ''}`;
                
                const netScore = stats.totalScore - stats.totalOpponentScore;
                const netScoreClass = netScore > 0 ? 'net-score-positive' : 
                                   netScore < 0 ? 'net-score-negative' : 'net-score-zero';
                
                row.innerHTML = `
                    <div class="rank-cell">${index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : index + 1}</div>
                    <div class="name-cell">${player}</div>
                    <div class="score-cell">${stats.wins}</div>
                    <div class="score-cell">${stats.losses}</div>
                    <div class="score-cell ${netScoreClass}">${netScore > 0 ? '+' : ''}${netScore}</div>
                `;
                resultsGrid.appendChild(row);
            });
        }

        // å¼¹æ¡†å‡½æ•°
        function showDialog(options) {
            const dialog = document.getElementById('customDialog');
            const icon = document.getElementById('dialogIcon');
            const iconText = document.getElementById('dialogIconText');
            const title = document.getElementById('dialogTitle');
            const message = document.getElementById('dialogMessage');
            const buttons = document.getElementById('dialogButtons');

            const iconMap = {
                info: { text: 'â„¹ï¸', class: 'info' },
                warning: { text: 'âš ï¸', class: 'warning' },
                success: { text: 'âœ…', class: 'success' },
                error: { text: 'âŒ', class: 'error' },
                question: { text: 'â“', class: 'info' }
            };

            const iconConfig = iconMap[options.type] || iconMap.info;
            iconText.textContent = iconConfig.text;
            icon.className = `dialog-icon ${iconConfig.class}`;

            title.textContent = options.title || 'æç¤º';
            message.textContent = options.message || '';

            buttons.innerHTML = '';
            if (options.buttons && options.buttons.length > 0) {
                options.buttons.forEach(btn => {
                    const button = document.createElement('button');
                    button.className = `dialog-btn ${btn.class || 'dialog-btn-secondary'}`;
                    button.textContent = btn.text;
                    button.onclick = () => {
                        closeDialog();
                        if (btn.onClick) btn.onClick();
                    };
                    buttons.appendChild(button);
                });
            } else {
                const okButton = document.createElement('button');
                okButton.className = 'dialog-btn dialog-btn-primary';
                okButton.textContent = 'ç¡®å®š';
                okButton.onclick = () => {
                    closeDialog();
                    if (options.onOk) options.onOk();
                };
                buttons.appendChild(okButton);
            }

            dialog.classList.add('active');
        }

        function closeDialog() {
            document.getElementById('customDialog').classList.remove('active');
        }

        function showAlert(message, title = 'æç¤º', type = 'info', onOk = null) {
            showDialog({
                type: type,
                title: title,
                message: message,
                onOk: onOk
            });
        }

        function showConfirm(message, title = 'ç¡®è®¤', onConfirm = null, onCancel = null) {
            showDialog({
                type: 'question',
                title: title,
                message: message,
                buttons: [
                    {
                        text: 'å–æ¶ˆ',
                        class: 'dialog-btn-secondary',
                        onClick: onCancel
                    },
                    {
                        text: 'ç¡®å®š',
                        class: 'dialog-btn-primary',
                        onClick: onConfirm
                    }
                ]
            });
        }

        // Loadingå‡½æ•°
        function showLoading(text = 'æ­£åœ¨è¿æ¥äº‘ç«¯...', subtitle = 'æ­£åœ¨ä»LeanCloudäº‘ç«¯åŠ è½½æœ€æ–°æ•°æ®') {
            const overlay = document.getElementById('loadingOverlay');
            const textEl = overlay.querySelector('.loading-text');
            const subtitleEl = overlay.querySelector('.loading-subtitle');
            
            textEl.textContent = text;
            subtitleEl.innerHTML = subtitle;
            overlay.style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // åŒæ­¥é€šçŸ¥
        function showSyncNotification(message, type = 'success') {
            let notification = document.getElementById('syncNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'syncNotification';
                notification.className = 'sync-notification';
                document.body.appendChild(notification);
            }
            
            // æ ¹æ®ç±»å‹è®¾ç½®ä¸åŒçš„èƒŒæ™¯é¢œè‰²
            if (type === 'warning' || message.includes('å¤±è´¥') || message.includes('æ¼”ç¤ºæ¨¡å¼')) {
                notification.style.background = 'linear-gradient(45deg, #ffc107, #fd7e14)';
            } else {
                notification.style.background = 'linear-gradient(45deg, #28a745, #20c997)';
            }
            
            notification.textContent = message;
            notification.style.opacity = '1';
            notification.style.transform = 'translateX(-50%) translateY(0)';
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(-50%) translateY(-20px)';
            }, 4000); // å»¶é•¿åˆ°4ç§’ï¼Œè®©ç”¨æˆ·æœ‰è¶³å¤Ÿæ—¶é—´çœ‹åˆ°
        }


        // é˜²æ­¢ä¸‹æ‹‰åˆ·æ–°
        function preventPullToRefresh() {
            let startY = 0;
            
            document.addEventListener('touchstart', function(e) {
                startY = e.touches[0].clientY;
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                const currentY = e.touches[0].clientY;
                const deltaY = currentY - startY;
                
                if (window.scrollY === 0 && deltaY > 0) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.body.style.overscrollBehavior = 'none';
            document.documentElement.style.overscrollBehavior = 'none';
        }

        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
        function debugLog(message) {
            console.log(`ğŸ¸ [Debug] ${message}`);
        }

        // æ£€æŸ¥å¿…è¦çš„å…ƒç´ æ˜¯å¦å­˜åœ¨
        function checkRequiredElements() {
            const requiredIds = ['playersNames', 'matchesPreview', 'loadingOverlay'];
            const missing = [];
            
            requiredIds.forEach(id => {
                if (!document.getElementById(id)) {
                    missing.push(id);
                }
            });
            
            if (missing.length > 0) {
                console.error('ç¼ºå°‘å¿…è¦å…ƒç´ :', missing);
                return false;
            }
            return true;
        }

        // ç‰ˆæœ¬æ£€æŸ¥å’Œç¼“å­˜ç ´å
        function checkVersionAndCache() {
            const currentVersion = '1.3.1';
            const lastVersion = localStorage.getItem('app_version');
            const lastCheck = localStorage.getItem('last_version_check');
            const now = Date.now();
            
            // æ˜¾ç¤ºå½“å‰ç‰ˆæœ¬ä¿¡æ¯
            console.log(`ğŸ¸ å½“å‰ç‰ˆæœ¬: ${currentVersion}`);
            
            // å¦‚æœç‰ˆæœ¬ä¸åŒ¹é…æˆ–è€…è¶…è¿‡1å°æ—¶æ²¡æ£€æŸ¥ï¼Œå¼ºåˆ¶åˆ·æ–°ç¼“å­˜
            if (lastVersion !== currentVersion || !lastCheck || (now - parseInt(lastCheck)) > 3600000) {
                console.log('ğŸ”„ æ£€æµ‹åˆ°ç‰ˆæœ¬æ›´æ–°æˆ–ç¼“å­˜è¿‡æœŸï¼Œæ¸…ç†ç¼“å­˜...');
                
                // æ¸…ç†æ‰€æœ‰ç›¸å…³ç¼“å­˜
                localStorage.removeItem('app_version');
                localStorage.removeItem('last_version_check');
                
                // æ¸…ç† Service Worker ç¼“å­˜ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.getRegistrations().then(registrations => {
                        registrations.forEach(registration => {
                            registration.unregister();
                        });
                    });
                }
                
                // æ¸…ç†æµè§ˆå™¨ç¼“å­˜
                if ('caches' in window) {
                    caches.keys().then(cacheNames => {
                        return Promise.all(
                            cacheNames.map(cacheName => caches.delete(cacheName))
                        );
                    });
                }
                
                // æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                localStorage.setItem('app_version', currentVersion);
                localStorage.setItem('last_version_check', now.toString());
                
                // å¦‚æœæ˜¯ç‰ˆæœ¬æ›´æ–°ï¼Œæ˜¾ç¤ºæç¤ºå¹¶å»ºè®®åˆ·æ–°
                if (lastVersion && lastVersion !== currentVersion) {
                    showSyncNotification(`ğŸ‰ ç³»ç»Ÿå·²æ›´æ–°åˆ° v${currentVersion}ï¼ä¸ºè·å¾—æœ€ä½³ä½“éªŒï¼Œå»ºè®®åˆ·æ–°é¡µé¢`);
                    
                    // 3ç§’åè‡ªåŠ¨åˆ·æ–°
                    setTimeout(() => {
                        if (confirm('æ£€æµ‹åˆ°ç³»ç»Ÿæ›´æ–°ï¼Œæ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢è·å–æœ€æ–°åŠŸèƒ½ï¼Ÿ')) {
                            location.reload(true); // å¼ºåˆ¶ä»æœåŠ¡å™¨é‡æ–°åŠ è½½
                        }
                    }, 3000);
                }
            } else {
                localStorage.setItem('last_version_check', now.toString());
            }
        }

        // å®‰å…¨çš„åˆå§‹åŒ–å‡½æ•°
        function safeInit() {
            try {
                debugLog('å¼€å§‹åˆå§‹åŒ–é¡µé¢');
                
                // é¦–å…ˆæ£€æŸ¥ç‰ˆæœ¬å’Œç¼“å­˜
                checkVersionAndCache();
                
                // æ£€æŸ¥å¿…è¦å…ƒç´ 
                if (!checkRequiredElements()) {
                    console.error('é¡µé¢å…ƒç´ æ£€æŸ¥å¤±è´¥');
                    return;
                }
                
                debugLog('åˆå§‹åŒ–äº‘ç«¯åŒæ­¥');
                // å…ˆåˆå§‹åŒ–äº‘ç«¯è¿æ¥ï¼Œè¿™æ ·å¯ä»¥ä»äº‘ç«¯åŠ è½½æ•°æ®
                saveToSync = initSimpleJsonSync();
                
                debugLog('åŠ è½½ç©å®¶é…ç½®');
                loadPlayerConfigFromCloud();
                
                debugLog('æ›´æ–°ç©å®¶æ˜¾ç¤º');
                updatePlayersDisplay();
                
                // æ³¨æ„ï¼šæ¯”èµ›æ•°æ®çš„ç”Ÿæˆ/åŠ è½½ç°åœ¨åœ¨ initSimpleJsonSync() çš„ init() å‡½æ•°ä¸­å¤„ç†
                // å¦‚æœäº‘ç«¯è¿æ¥æˆåŠŸï¼Œä¼šä»äº‘ç«¯åŠ è½½æ•°æ®
                // å¦‚æœäº‘ç«¯è¿æ¥å¤±è´¥ï¼Œä¼šåœ¨æ¼”ç¤ºæ¨¡å¼ä¸­ç”Ÿæˆæ–°æ•°æ®
                
                debugLog('è®¾ç½®é˜²åˆ·æ–°');
                preventPullToRefresh();
                
                debugLog('åˆå§‹åŒ–å®Œæˆ');
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ç»™ç”¨æˆ·
                const container = document.getElementById('matchesPreview');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: #f8d7da; border-radius: 10px; color: #721c24; margin: 20px 0;">
                            <h3>âš ï¸ åˆå§‹åŒ–å¤±è´¥</h3>
                            <p>é¡µé¢åŠ è½½å‡ºç°é—®é¢˜ï¼Œè¯·åˆ·æ–°é‡è¯•</p>
                            <p style="font-size: 0.8rem; margin-top: 10px;">é”™è¯¯ä¿¡æ¯: ${error.message}</p>
                            <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                åˆ·æ–°é¡µé¢
                            </button>
                        </div>
                    `;
                }
            }
        }

        // å…¨å±€æ­é…ç®¡ç†å™¨
        class PartnershipManager {
            constructor(playerCount) {
                this.playerCount = playerCount;
                this.maxCount = playerCount === 5 ? 3 : 2; // 5äººæ¨¡å¼3æ¬¡ï¼Œ6äººæ¨¡å¼2æ¬¡
                this.targetCount = playerCount === 5 ? 3 : 2; // 5äººæ¨¡å¼ç†è®º3æ¬¡ï¼Œ6äººæ¨¡å¼ç†è®º2æ¬¡
                this.minCount = playerCount === 5 ? 2 : 1; // 5äººæ¨¡å¼æœ€å°‘2æ¬¡ï¼Œ6äººæ¨¡å¼æœ€å°‘1æ¬¡
                this.partnerships = {};
                this.reset();
            }
            
            reset() {
                this.partnerships = {};
                for (let i = 0; i < this.playerCount; i++) {
                    for (let j = i + 1; j < this.playerCount; j++) {
                        this.partnerships[`${i}-${j}`] = 0;
                    }
                }
                console.log(`ğŸ¤ æ­é…ç®¡ç†å™¨é‡ç½® (${this.playerCount}äººæ¨¡å¼ï¼Œæ¯å¯¹æœ€å¤š${this.maxCount}æ¬¡)`);
            }
            
            getPartnershipKey(player1, player2) {
                return `${Math.min(player1, player2)}-${Math.max(player1, player2)}`;
            }
            
            getCount(player1, player2) {
                const key = this.getPartnershipKey(player1, player2);
                return this.partnerships[key] || 0;
            }
            
            canPartner(player1, player2) {
                const count = this.getCount(player1, player2);
                return count < this.maxCount;
            }
            
            addPartnership(player1, player2) {
                const key = this.getPartnershipKey(player1, player2);
                this.partnerships[key] = (this.partnerships[key] || 0) + 1;
                const newCount = this.partnerships[key];
                
                if (newCount > this.maxCount) {
                    console.error(`âŒ æ­é…è¶…æ ‡: ç©å®¶${player1+1} + ç©å®¶${player2+1} = ${newCount}æ¬¡ (æœ€å¤š${this.maxCount}æ¬¡)`);
                }
                
                return newCount;
            }
            
            canFormTeam(team1, team2) {
                // æ£€æŸ¥ä¸¤ä¸ªé˜Ÿä¼çš„æ­é…æ˜¯å¦éƒ½åœ¨é™åˆ¶å†…
                return this.canPartner(team1[0], team1[1]) && this.canPartner(team2[0], team2[1]);
            }
            
            addTeams(team1, team2) {
                this.addPartnership(team1[0], team1[1]);
                this.addPartnership(team2[0], team2[1]);
            }
            
            getPartnershipScore(player1, player2) {
                const count = this.getCount(player1, player2);
                const remaining = this.maxCount - count;
                const deficit = this.targetCount - count; // ä¸ç›®æ ‡çš„å·®è·
                
                // è®¡ç®—ä¼˜å…ˆçº§åˆ†æ•° - å¼ºçƒˆå€¾å‘äºè¾¾åˆ°ç›®æ ‡æ­é…æ¬¡æ•°
                let score = remaining * 2000; // åŸºç¡€åˆ†æ•°
                
                if (count === 0) {
                    score += 20000; // æå¤§æå‡ä»æœªæ­é…è¿‡çš„æƒé‡
                } else if (count < this.targetCount) {
                    // ä½äºç›®æ ‡æ¬¡æ•°ï¼Œç»™äºˆå¥–åŠ±ï¼Œå·®è·è¶Šå¤§å¥–åŠ±è¶Šå¤š
                    score += deficit * 8000;
                } else if (count === this.targetCount) {
                    score += 1000; // å·²è¾¾åˆ°ç›®æ ‡ï¼Œå°å¹…å¥–åŠ±
                } else if (count < this.maxCount) {
                    score -= (count - this.targetCount) * 3000; // è¶…è¿‡ç›®æ ‡ä½†æœªè¾¾ä¸Šé™ï¼Œç»™äºˆæƒ©ç½š
                } else {
                    score -= 50000; // ä¸¥é‡æƒ©ç½šè¶…æ ‡æ­é…
                }
                
                return score;
            }
            
            // è·å–æ­é…åˆ†å¸ƒçš„å‡è¡¡æ€§è¯„åˆ†
            getBalanceScore() {
                const counts = Object.values(this.partnerships);
                const nonZeroCounts = counts.filter(c => c > 0);
                
                if (nonZeroCounts.length === 0) return 0;
                
                const min = Math.min(...nonZeroCounts);
                const max = Math.max(...nonZeroCounts);
                const avg = nonZeroCounts.reduce((a, b) => a + b, 0) / nonZeroCounts.length;
                
                // è®¡ç®—æ ‡å‡†å·®
                const variance = nonZeroCounts.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / nonZeroCounts.length;
                const stdDev = Math.sqrt(variance);
                
                // å‡è¡¡æ€§åˆ†æ•°ï¼šè¶Šå°è¶Šå¥½ï¼ˆæ ‡å‡†å·®è¶Šå°ï¼Œåˆ†å¸ƒè¶Šå‡åŒ€ï¼‰
                return { min, max, avg, stdDev, balance: max - min };
            }
            
            // è·å–æœ€å°‘æ­é…æ¬¡æ•°çš„æ‰€æœ‰ç»„åˆ
            getLeastUsedPairs() {
                const minCount = Math.min(...Object.values(this.partnerships));
                const leastUsed = [];
                
                Object.entries(this.partnerships).forEach(([key, count]) => {
                    if (count === minCount) {
                        const [id1, id2] = key.split('-').map(Number);
                        leastUsed.push([id1, id2]);
                    }
                });
                
                return leastUsed;
            }
            
            // è·å–ä½äºç›®æ ‡æ­é…æ¬¡æ•°çš„æ‰€æœ‰ç»„åˆ
            getUnderTargetPairs() {
                const underTarget = [];
                
                Object.entries(this.partnerships).forEach(([key, count]) => {
                    if (count < this.targetCount) {
                        const [id1, id2] = key.split('-').map(Number);
                        underTarget.push([id1, id2]);
                    }
                });
                
                return underTarget;
            }
            
            // æ£€æŸ¥æŸä¸ªæ­é…ç»„åˆæ˜¯å¦åŒ…å«æœ€å°‘ä½¿ç”¨çš„é…å¯¹
            containsLeastUsedPair(team1, team2) {
                const leastUsed = this.getLeastUsedPairs();
                
                for (const [id1, id2] of leastUsed) {
                    // æ£€æŸ¥team1æ˜¯å¦åŒ¹é…
                    if ((team1[0] === id1 && team1[1] === id2) || (team1[0] === id2 && team1[1] === id1)) {
                        return true;
                    }
                    // æ£€æŸ¥team2æ˜¯å¦åŒ¹é…
                    if ((team2[0] === id1 && team2[1] === id2) || (team2[0] === id2 && team2[1] === id1)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // æ£€æŸ¥æŸä¸ªæ­é…ç»„åˆæ˜¯å¦åŒ…å«ä½äºç›®æ ‡çš„é…å¯¹
            containsUnderTargetPair(team1, team2) {
                const underTarget = this.getUnderTargetPairs();
                
                for (const [id1, id2] of underTarget) {
                    // æ£€æŸ¥team1æ˜¯å¦åŒ¹é…
                    if ((team1[0] === id1 && team1[1] === id2) || (team1[0] === id2 && team1[1] === id1)) {
                        return true;
                    }
                    // æ£€æŸ¥team2æ˜¯å¦åŒ¹é…
                    if ((team2[0] === id1 && team2[1] === id2) || (team2[0] === id2 && team2[1] === id1)) {
                        return true;
                    }
                }
                
                return false;
            }

            printStats() {
                console.log('ğŸ¤ å½“å‰æ­é…ç»Ÿè®¡ï¼š');
                Object.entries(this.partnerships).forEach(([key, count]) => {
                    const [id1, id2] = key.split('-').map(Number);
                    let status = '';
                    if (count === 0) {
                        status = ' âŒæœªæ­é…';
                    } else if (count < this.targetCount) {
                        status = ' âš ï¸ä¸è¶³';
                    } else if (count === this.targetCount) {
                        status = ' âœ…ç†æƒ³';
                    } else if (count <= this.maxCount) {
                        status = ' ğŸ”¸åå¤š';
                    } else {
                        status = ' âŒè¶…æ ‡';
                    }
                    
                    console.log(`  ç©å®¶${id1+1} + ç©å®¶${id2+1}: ${count}æ¬¡${status}`);
                });
                
                const balance = this.getBalanceScore();
                console.log(`ğŸ“Š å‡è¡¡æ€§: æœ€å°‘${balance.min}æ¬¡, æœ€å¤š${balance.max}æ¬¡, å¹³å‡${balance.avg.toFixed(1)}æ¬¡, å·®è·${balance.balance}æ¬¡`);
                console.log(`ğŸ¯ ç›®æ ‡: æ¯å¯¹æ­é…${this.targetCount}æ¬¡, æœ€å¤š${this.maxCount}æ¬¡`);
            }
        }
        
        // å…¨å±€æ­é…ç®¡ç†å™¨å®ä¾‹
        let globalPartnershipManager = null;

        // ===========================================
        // å…¨æ–°çš„ç®€å•åˆ†é…ç®—æ³•
        // ===========================================

        // 6äººæ¨¡å¼ï¼šæ¯äºº10åœºï¼Œæ¯å¯¹æ­é…æ°å¥½2æ¬¡
        function generateSimple6PlayerSchedule(players) {
            console.log('ğŸ¯ æ–°ç®—æ³•ï¼š6äººæ¨¡å¼ - æ¯äºº10åœºï¼Œæ¯å¯¹æ­é…2æ¬¡');
            
            // 6äºº15åœºçš„æ•°å­¦éªŒè¯ï¼š
            // - æ€»å…±15åœºæ¯”èµ›ï¼Œæ¯åœº4äººï¼Œå…±60äººæ¬¡
            // - 6äººå¹³å‡ï¼š60Ã·6=10åœº/äºº âœ“
            // - æ€»å…±15ç§æ­é…å…³ç³»ï¼ˆC(6,2)=15ï¼‰
            // - æ¯åœºäº§ç”Ÿ2ä¸ªæ­é…ï¼Œå…±30ä¸ªæ­é…å®ä¾‹
            // - å¹³å‡æ¯å¯¹ï¼š30Ã·15=2æ¬¡æ­é… âœ“
            
            const matchTemplates = generate6PlayerOptimalMatches();
            
            // å°†æ•°å­—æ¨¡æ¿è½¬æ¢ä¸ºç©å®¶åå­—
            const matches = matchTemplates.map((template, index) => ({
                team1: [players[template.team1[0]], players[template.team1[1]]],
                team2: [players[template.team2[0]], players[template.team2[1]]],
                score1: 0,
                score2: 0,
                matchIndex: index
            }));
            
            console.log(`âœ… 6äººå®Œç¾å®‰æ’ç”Ÿæˆå®Œæˆï¼š${matches.length}åœºæ¯”èµ›`);
            return matches;
        }

        // 5äººæ¨¡å¼ï¼šæ¯äºº12åœºï¼Œæ¯å¯¹æ­é…2-3æ¬¡
        function generateSimple5PlayerSchedule(players) {
            console.log('ğŸ¯ æ–°ç®—æ³•ï¼š5äººæ¨¡å¼ - æ¯äºº12åœºï¼Œæ¯å¯¹æ­é…2-3æ¬¡');
            
            // 5äºº15åœºçš„æ•°å­¦éªŒè¯ï¼š
            // - æ€»å…±15åœºæ¯”èµ›ï¼Œæ¯åœº4äººï¼Œå…±60äººæ¬¡
            // - 5äººå¹³å‡ï¼š60Ã·5=12åœº/äºº âœ“
            // - æ€»å…±10ç§æ­é…å…³ç³»ï¼ˆC(5,2)=10ï¼‰
            // - æ¯åœºäº§ç”Ÿ2ä¸ªæ­é…ï¼Œå…±30ä¸ªæ­é…å®ä¾‹
            // - å¹³å‡æ¯å¯¹ï¼š30Ã·10=3æ¬¡æ­é…ï¼Œå®é™…ä¼šæ˜¯2-3æ¬¡ âœ“
            
            const schedule = generate5PlayerOptimalMatches();
            return convertScheduleToMatches(schedule, players);
        }

        // ç”Ÿæˆ6äººæœ€ä¼˜æ¯”èµ›å®‰æ’ - ä½¿ç”¨ç®—æ³•ç”Ÿæˆç¡®ä¿æ•°å­¦æ­£ç¡®
        function generate6PlayerOptimalMatches() {
            console.log('ğŸ“Š 6äººæ¨¡å¼ç®—æ³•æ„é€ å¼€å§‹...');
            
            // ä½¿ç”¨ç³»ç»ŸåŒ–ç®—æ³•ç”Ÿæˆç¡®ä¿æ¯äºº10åœºï¼Œæ¯å¯¹æ­é…2æ¬¡çš„å®‰æ’
            const matches = [];
            const playerCounts = Array(6).fill(0);
            const partnerships = {};
            
            // åˆå§‹åŒ–æ­é…è®¡æ•°å™¨
            for (let i = 0; i < 6; i++) {
                for (let j = i + 1; j < 6; j++) {
                    partnerships[`${i}-${j}`] = 0;
                }
            }
            
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æ¯”èµ›ç»„åˆï¼ˆ15ç§4äººç»„åˆï¼‰
            const allMatches = [];
            for (let i = 0; i < 6; i++) {
                for (let j = i + 1; j < 6; j++) {
                    for (let k = j + 1; k < 6; k++) {
                        for (let l = k + 1; l < 6; l++) {
                            // 4äººç»„åˆ[i,j,k,l]çš„3ç§åˆ†é˜Ÿæ–¹å¼
                            allMatches.push({ team1: [i,j], team2: [k,l], players: [i,j,k,l] });
                            allMatches.push({ team1: [i,k], team2: [j,l], players: [i,j,k,l] });
                            allMatches.push({ team1: [i,l], team2: [j,k], players: [i,j,k,l] });
                        }
                    }
                }
            }
            
            console.log(`æ€»å…±æœ‰${allMatches.length}ç§å¯èƒ½çš„æ¯”èµ›å®‰æ’`);
            
            // ä½¿ç”¨è´ªå¿ƒç®—æ³•é€‰æ‹©15åœºæ¯”èµ›ï¼Œç¡®ä¿æ¯äºº10åœºï¼Œæ¯å¯¹æ­é…2æ¬¡
            for (let round = 0; round < 15; round++) {
                let bestMatch = null;
                let bestScore = -Infinity;
                
                for (const match of allMatches) {
                    // æ£€æŸ¥è¿™åœºæ¯”èµ›æ˜¯å¦ä¼šè®©ä»»ä½•äººè¶…è¿‡10åœº
                    const wouldExceed = match.players.some(p => playerCounts[p] >= 10);
                    if (wouldExceed) continue;
                    
                    // æ£€æŸ¥æ­é…æ˜¯å¦ä¼šè¶…è¿‡2æ¬¡
                    const team1Key = `${Math.min(match.team1[0], match.team1[1])}-${Math.max(match.team1[0], match.team1[1])}`;
                    const team2Key = `${Math.min(match.team2[0], match.team2[1])}-${Math.max(match.team2[0], match.team2[1])}`;
                    
                    if (partnerships[team1Key] >= 2 || partnerships[team2Key] >= 2) continue;
                    
                    // è®¡ç®—è¿™åœºæ¯”èµ›çš„ä¼˜å…ˆçº§åˆ†æ•°
                    let score = 0;
                    
                    // ä¼˜å…ˆé€‰æ‹©è®©å‚èµ›æ¬¡æ•°å°‘çš„äººå‚èµ›
                    match.players.forEach(p => {
                        score += (10 - playerCounts[p]) * 100;
                    });
                    
                    // ä¼˜å…ˆé€‰æ‹©æ­é…æ¬¡æ•°å°‘çš„ç»„åˆ
                    score += (2 - partnerships[team1Key]) * 1000;
                    score += (2 - partnerships[team2Key]) * 1000;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = match;
                    }
                }
                
                if (!bestMatch) {
                    throw new Error(`ç¬¬${round + 1}åœºæ¯”èµ›æ— æ³•å®‰æ’`);
                }
                
                // æ·»åŠ è¿™åœºæ¯”èµ›
                matches.push(bestMatch);
                
                // æ›´æ–°è®¡æ•°å™¨
                bestMatch.players.forEach(p => playerCounts[p]++);
                const team1Key = `${Math.min(bestMatch.team1[0], bestMatch.team1[1])}-${Math.max(bestMatch.team1[0], bestMatch.team1[1])}`;
                const team2Key = `${Math.min(bestMatch.team2[0], bestMatch.team2[1])}-${Math.max(bestMatch.team2[0], bestMatch.team2[1])}`;
                partnerships[team1Key]++;
                partnerships[team2Key]++;
                
                console.log(`ç¬¬${round + 1}åœº: [${bestMatch.team1.join(',')}] vs [${bestMatch.team2.join(',')}], å½“å‰åœºæ¬¡: [${playerCounts.join(',')}]`);
            }
            
            // éªŒè¯è¿™ä¸ªå®‰æ’
            if (!validatePerfect6PlayerMatches(matches)) {
                throw new Error('6äººç®—æ³•ç”ŸæˆéªŒè¯å¤±è´¥');
            }
            
            console.log('âœ… 6äººç®—æ³•ç”ŸæˆéªŒè¯é€šè¿‡');
            return matches;
        }
        
        // éªŒè¯6äººå®Œç¾å®‰æ’
        function validatePerfect6PlayerMatches(matches) {
            console.log('ğŸ” éªŒè¯6äººå®Œç¾å®‰æ’...');
            
            // ç»Ÿè®¡æ¯äººå‚ä¸æ¬¡æ•°
            const playerCounts = Array(6).fill(0);
            // ç»Ÿè®¡æ¯å¯¹æ­é…æ¬¡æ•°
            const partnerships = {};
            for (let i = 0; i < 6; i++) {
                for (let j = i + 1; j < 6; j++) {
                    partnerships[`${i}-${j}`] = 0;
                }
            }
            
            matches.forEach(match => {
                // ç»Ÿè®¡å‚ä¸æ¬¡æ•°
                match.team1.forEach(p => playerCounts[p]++);
                match.team2.forEach(p => playerCounts[p]++);
                
                // ç»Ÿè®¡æ­é…æ¬¡æ•°
                const key1 = `${Math.min(match.team1[0], match.team1[1])}-${Math.max(match.team1[0], match.team1[1])}`;
                const key2 = `${Math.min(match.team2[0], match.team2[1])}-${Math.max(match.team2[0], match.team2[1])}`;
                partnerships[key1]++;
                partnerships[key2]++;
            });
            
            // æ£€æŸ¥æ¯äººæ˜¯å¦éƒ½æ˜¯10åœº
            const allTen = playerCounts.every(count => count === 10);
            if (!allTen) {
                console.error(`âŒ åœºæ¬¡åˆ†é…é”™è¯¯ï¼š[${playerCounts.join(',')}]ï¼Œåº”è¯¥æ¯äºº10åœº`);
                return false;
            }
            
            // æ£€æŸ¥æ¯å¯¹æ˜¯å¦éƒ½æ˜¯2æ¬¡æ­é…
            const allTwo = Object.values(partnerships).every(count => count === 2);
            if (!allTwo) {
                console.error('âŒ æ­é…åˆ†é…é”™è¯¯ï¼š');
                Object.entries(partnerships).forEach(([key, count]) => {
                    if (count !== 2) {
                        console.error(`  ${key}: ${count}æ¬¡ï¼Œåº”è¯¥2æ¬¡`);
                    }
                });
                return false;
            }
            
            console.log('âœ… éªŒè¯é€šè¿‡ï¼šæ¯äºº10åœºï¼Œæ¯å¯¹æ­é…2æ¬¡');
            return true;
        }

        // ç”Ÿæˆ5äººæœ€ä¼˜æ¯”èµ›å®‰æ’
        function generate5PlayerOptimalMatches() {
            console.log('ğŸ“Š 5äººæ¨¡å¼æ•°å­¦æ„é€ å¼€å§‹...');
            
            // 5äººè½®è½¬ä¼‘æ¯ï¼Œ15åœºæ¯”èµ›çš„æœ€ä¼˜å®‰æ’
            // æ¯äººä¼‘æ¯3åœºï¼Œå‚ä¸12åœº
            const schedule = [
                // ç©å®¶0ä¼‘æ¯çš„3åœº
                [1,2,3,4], [1,3,2,4], [1,4,2,3],
                // ç©å®¶1ä¼‘æ¯çš„3åœº  
                [0,2,3,4], [0,3,2,4], [0,4,2,3],
                // ç©å®¶2ä¼‘æ¯çš„3åœº
                [0,1,3,4], [0,3,1,4], [0,4,1,3],
                // ç©å®¶3ä¼‘æ¯çš„3åœº
                [0,1,2,4], [0,2,1,4], [0,4,1,2],
                // ç©å®¶4ä¼‘æ¯çš„3åœº
                [0,1,2,3], [0,2,1,3], [0,3,1,2]
            ];
            
            // éªŒè¯è¿™ä¸ªå®‰æ’
            if (!validate5PlayerSchedule(schedule)) {
                throw new Error('5äººæ•°å­¦æ„é€ éªŒè¯å¤±è´¥');
            }
            
            console.log('âœ… 5äººå®‰æ’éªŒè¯é€šè¿‡');
            return schedule;
        }


        // éªŒè¯5äººå®‰æ’çš„æ­£ç¡®æ€§
        function validate5PlayerSchedule(schedule) {
            console.log('ğŸ” éªŒè¯5äººå®‰æ’...');
            
            // æ£€æŸ¥æ€»åœºæ¬¡
            if (schedule.length !== 15) {
                console.error(`âŒ æ€»åœºæ¬¡é”™è¯¯ï¼š${schedule.length}ï¼Œåº”è¯¥15åœº`);
                return false;
            }
            
            // ç»Ÿè®¡æ¯äººå‚ä¸æ¬¡æ•°
            const playerCounts = Array(5).fill(0);
            schedule.forEach(match => {
                if (match.length !== 4) {
                    console.error(`âŒ åœºæ¬¡äººæ•°é”™è¯¯ï¼š${match.length}äººï¼Œåº”è¯¥4äºº`);
                    return false;
                }
                match.forEach(playerId => playerCounts[playerId]++);
            });
            
            // æ£€æŸ¥æ¯äººæ˜¯å¦éƒ½æ˜¯12åœº
            const allTwelve = playerCounts.every(count => count === 12);
            if (!allTwelve) {
                console.error(`âŒ åœºæ¬¡åˆ†é…é”™è¯¯ï¼š[${playerCounts.join(',')}]ï¼Œåº”è¯¥æ¯äºº12åœº`);
                return false;
            }
            
            // ç»Ÿè®¡æ­é…æ¬¡æ•°
            const partnerships = {};
            for (let i = 0; i < 5; i++) {
                for (let j = i + 1; j < 5; j++) {
                    partnerships[`${i}-${j}`] = 0;
                }
            }
            
            schedule.forEach(match => {
                // ç»Ÿè®¡è¿™åœºæ¯”èµ›ä¸­çš„æ‰€æœ‰æ­é…
                for (let i = 0; i < match.length; i++) {
                    for (let j = i + 1; j < match.length; j++) {
                        const key = `${Math.min(match[i], match[j])}-${Math.max(match[i], match[j])}`;
                        partnerships[key]++;
                    }
                }
            });
            
            // æ£€æŸ¥æ­é…åˆ†å¸ƒï¼šåº”è¯¥2-3æ¬¡
            const partnerCounts = Object.values(partnerships);
            const validRange = partnerCounts.every(count => count >= 2 && count <= 3);
            if (!validRange) {
                console.error(`âŒ æ­é…åˆ†é…é”™è¯¯ï¼š${JSON.stringify(partnerships)}`);
                return false;
            }
            
            console.log('âœ… 5äººéªŒè¯ï¼šæ¯äºº12åœºï¼Œæ¯å¯¹2-3æ¬¡æ­é…');
            return true;
        }

        // å°†æ•°å­—å®‰æ’è½¬æ¢ä¸ºå®é™…æ¯”èµ›æ ¼å¼
        function convertScheduleToMatches(schedule, players) {
            const matches = [];
            
            schedule.forEach((match, index) => {
                let team1, team2;
                
                if (match.team1 && match.team2) {
                    // å¦‚æœå·²ç»æŒ‡å®šäº†é˜Ÿä¼åˆ†é…ï¼Œç›´æ¥ä½¿ç”¨
                    team1 = [players[match.team1[0]], players[match.team1[1]]];
                    team2 = [players[match.team2[0]], players[match.team2[1]]];
                } else {
                    // å¦‚æœåªæ˜¯4äººæ•°ç»„ï¼Œéšæœºåˆ†é˜Ÿï¼ˆç”¨äº5äººæ¨¡å¼ï¼‰
                    const shuffled = [...match].sort(() => Math.random() - 0.5);
                    team1 = [players[shuffled[0]], players[shuffled[1]]];
                    team2 = [players[shuffled[2]], players[shuffled[3]]];
                }
                
                matches.push({
                    team1: team1,
                    team2: team2,
                    score1: 0,
                    score2: 0,
                    matchIndex: index
                });
            });
            
            console.log(`âœ… è½¬æ¢å®Œæˆï¼š${matches.length}åœºæ¯”èµ›`);
            return matches;
        }

        // å¼ºåˆ¶åˆ·æ–°å‡½æ•°
        function forceRefresh() {
            // æ¸…ç†æ‰€æœ‰ç¼“å­˜
            localStorage.clear();
            sessionStorage.clear();
            
            // æ¸…ç† Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(registration => {
                        registration.unregister();
                    });
                });
            }
            
            // æ¸…ç†æµè§ˆå™¨ç¼“å­˜
            if ('caches' in window) {
                caches.keys().then(cacheNames => {
                    return Promise.all(
                        cacheNames.map(cacheName => caches.delete(cacheName))
                    );
                });
            }
            
            // æ˜¾ç¤ºæç¤º
            showSyncNotification('ğŸ”„ æ­£åœ¨æ¸…ç†ç¼“å­˜å¹¶åˆ·æ–°...');
            
            // å»¶è¿Ÿåˆ·æ–°ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æç¤º
            setTimeout(() => {
                // ä½¿ç”¨æ—¶é—´æˆ³å¼ºåˆ¶ç»•è¿‡ç¼“å­˜
                const url = window.location.href;
                const separator = url.includes('?') ? '&' : '?';
                window.location.href = url + separator + '_t=' + Date.now();
            }, 1000);
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('DOMåŠ è½½å®Œæˆ');
            safeInit();
        });

        // å¤‡ç”¨åˆå§‹åŒ–ï¼ˆå¦‚æœ DOMContentLoaded å·²ç»è§¦å‘ï¼‰
        if (document.readyState === 'loading') {
            debugLog('ç­‰å¾…DOMåŠ è½½');
        } else {
            debugLog('DOMå·²ç»åŠ è½½ï¼Œç«‹å³åˆå§‹åŒ–');
            setTimeout(safeInit, 100); // ç¨å¾®å»¶è¿Ÿç¡®ä¿æ‰€æœ‰è„šæœ¬éƒ½åŠ è½½å®Œæˆ
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('advancedScoreModal').addEventListener('click', function(e) {
            if (e.target === this) closeAdvancedScoreModal();
        });

        document.getElementById('playerConfigModal').addEventListener('click', function(e) {
            if (e.target === this) closePlayerConfigModal();
        });

        document.getElementById('scheduleModal').addEventListener('click', function(e) {
            if (e.target === this) closeScheduleModal();
        });

        document.getElementById('customDialog').addEventListener('click', function(e) {
            if (e.target === this) closeDialog();
        });

    </script>
</body>
</html>

